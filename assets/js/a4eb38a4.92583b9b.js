"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[9528],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>b});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},s=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),u=p(n),d=i,b=u["".concat(l,".").concat(d)]||u[d]||h[d]||r;return n?a.createElement(b,o(o({ref:t},s),{},{components:n})):a.createElement(b,o({ref:t},s))}));function b(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=d;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c[u]="string"==typeof e?e:i,o[1]=c;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},29057:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>c,toc:()=>p});var a=n(87462),i=(n(67294),n(3905));const r={title:"Capability-based Access Control"},o=void 0,c={unversionedId:"cadence/language/capability-based-access-control",id:"cadence/language/capability-based-access-control",title:"Capability-based Access Control",description:"Users will often want to make it so that specific other users or even anyone else",source:"@site/docs/cadence/language/capability-based-access-control.md",sourceDirName:"cadence/language",slug:"/cadence/language/capability-based-access-control",permalink:"/cadence/language/capability-based-access-control",draft:!1,tags:[],version:"current",lastUpdatedBy:"Tom Haile",lastUpdatedAt:1682618386,formattedLastUpdatedAt:"Apr 27, 2023",frontMatter:{title:"Capability-based Access Control"},sidebar:"tutorialSidebar",previous:{title:"Built-in Functions",permalink:"/cadence/language/built-in-functions"},next:{title:"Composite Types",permalink:"/cadence/language/composite-types"}},l={},p=[],s={toc:p},u="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Users will often want to make it so that specific other users or even anyone else\ncan access certain fields and functions of a stored object.\nThis can be done by creating a capability."),(0,i.kt)("p",null,"As was mentioned before, access to stored objects is governed by the\ntenets of ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Capability-based_security"},"Capability Security"),".\nThis means that if an account wants to be able to access another account's\nstored objects, it must have a valid capability to that object."),(0,i.kt)("p",null,"Capabilities are identified by a path and link to a target path, not directly to an object.\nCapabilities are either public (any user can get access),\nor private (access to/from the authorized user is necessary)."),(0,i.kt)("p",null,"Public capabilities are created using public paths, i.e. they have the domain ",(0,i.kt)("inlineCode",{parentName:"p"},"public"),".\nAfter creation they can be obtained from both authorized accounts (",(0,i.kt)("inlineCode",{parentName:"p"},"AuthAccount"),")\nand public accounts (",(0,i.kt)("inlineCode",{parentName:"p"},"PublicAccount"),")."),(0,i.kt)("p",null,"Private capabilities are created using private paths, i.e. they have the domain ",(0,i.kt)("inlineCode",{parentName:"p"},"private"),".\nAfter creation they can be obtained from authorized accounts (",(0,i.kt)("inlineCode",{parentName:"p"},"AuthAccount"),"),\nbut not from public accounts (",(0,i.kt)("inlineCode",{parentName:"p"},"PublicAccount"),")."),(0,i.kt)("p",null,"Once a capability is created and obtained, it can be borrowed to get a reference\nto the stored object.\nWhen a capability is created, a type is specified that determines as what type\nthe capability can be borrowed.\nThis allows exposing and hiding certain functionality of a stored object."),(0,i.kt)("p",null,"Capabilities are created using the ",(0,i.kt)("inlineCode",{parentName:"p"},"link")," function of an authorized account (",(0,i.kt)("inlineCode",{parentName:"p"},"AuthAccount"),"):"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cadence"},"fun link<T: &Any>(_ newCapabilityPath: CapabilityPath, target: Path): Capability<T>?\n")),(0,i.kt)("p",{parentName:"li"},"   ",(0,i.kt)("inlineCode",{parentName:"p"},"newCapabilityPath")," is the public or private path identifying the new capability."),(0,i.kt)("p",{parentName:"li"},"   ",(0,i.kt)("inlineCode",{parentName:"p"},"target")," is any public, private, or storage path that leads to the object\nthat will provide the functionality defined by this capability."),(0,i.kt)("p",{parentName:"li"},"   ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," is the type parameter for the capability type.\nA type argument for the parameter must be provided explicitly."),(0,i.kt)("p",{parentName:"li"},"   The type parameter defines how the capability can be borrowed,\ni.e., how the stored value can be accessed."),(0,i.kt)("p",{parentName:"li"},"   The link function returns ",(0,i.kt)("inlineCode",{parentName:"p"},"nil")," if a link for the given capability path already exists,\nor the newly created capability if not."),(0,i.kt)("p",{parentName:"li"},"   It is not necessary for the target path to lead to a valid object;\nthe target path could be empty, or could lead to an object\nwhich does not provide the necessary type interface:"),(0,i.kt)("p",{parentName:"li"},"   The link function does ",(0,i.kt)("strong",{parentName:"p"},"not")," check if the target path is valid/exists at the time\nthe capability is created and does ",(0,i.kt)("strong",{parentName:"p"},"not")," check if the target value conforms to the given type."),(0,i.kt)("p",{parentName:"li"},"   The link is latent.\nThe target value might be stored after the link is created,\nand the target value might be moved out after the link has been created."))),(0,i.kt)("p",null,"Capabilities can be removed using the ",(0,i.kt)("inlineCode",{parentName:"p"},"unlink")," function of an authorized account (",(0,i.kt)("inlineCode",{parentName:"p"},"AuthAccount"),"):"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cadence"},"fun unlink(_ path: CapabilityPath)\n")),(0,i.kt)("p",{parentName:"li"},"   ",(0,i.kt)("inlineCode",{parentName:"p"},"path")," is the public or private path identifying the capability that should be removed."))),(0,i.kt)("p",null,"To get the target path for a capability, the ",(0,i.kt)("inlineCode",{parentName:"p"},"getLinkTarget")," function\nof an authorized account (",(0,i.kt)("inlineCode",{parentName:"p"},"AuthAccount"),") or public account (",(0,i.kt)("inlineCode",{parentName:"p"},"PublicAccount"),") can be used:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cadence"},"fun getLinkTarget(_ path: CapabilityPath): Path?\n")),(0,i.kt)("p",{parentName:"li"},"   ",(0,i.kt)("inlineCode",{parentName:"p"},"path")," is the public or private path identifying the capability.\nThe function returns the link target path,\nif a capability exists at the given path,\nor ",(0,i.kt)("inlineCode",{parentName:"p"},"nil")," if it does not."))),(0,i.kt)("p",null,"Existing capabilities can be obtained by using the ",(0,i.kt)("inlineCode",{parentName:"p"},"getCapability")," function\nof authorized accounts (",(0,i.kt)("inlineCode",{parentName:"p"},"AuthAccount"),") and public accounts (",(0,i.kt)("inlineCode",{parentName:"p"},"PublicAccount"),"):"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cadence"},"fun getCapability<T>(_ at: CapabilityPath): Capability<T>\n")),(0,i.kt)("p",{parentName:"li"},"   For public accounts, the function returns a capability\nif the given path is public.\nIt is not possible to obtain private capabilities from public accounts.\nIf the path is private or a storage path, the function returns ",(0,i.kt)("inlineCode",{parentName:"p"},"nil"),"."),(0,i.kt)("p",{parentName:"li"},"   For authorized accounts, the function returns a capability\nif the given path is public or private.\nIf the path is a storage path, the function returns ",(0,i.kt)("inlineCode",{parentName:"p"},"nil"),"."),(0,i.kt)("p",{parentName:"li"},"   ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," is the type parameter that specifies how the capability can be borrowed.\nThe type argument is optional, i.e. it need not be provided."))),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"getCapability")," function does ",(0,i.kt)("strong",{parentName:"p"},"not")," check if the target exists.\nThe link is latent.\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"check")," function of the capability can be used to check if the target currently exists and could be borrowed,"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cadence"},"fun check<T: &Any>(): Bool\n")),(0,i.kt)("p",{parentName:"li"},"   ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," is the type parameter for the reference type.\nA type argument for the parameter must be provided explicitly."),(0,i.kt)("p",{parentName:"li"},"   The function returns true if the capability currently targets an object\nthat satisfies the given type, i.e. could be borrowed using the given type."))),(0,i.kt)("p",null,"Finally, the capability can be borrowed to get a reference to the stored object.\nThis can be done using the ",(0,i.kt)("inlineCode",{parentName:"p"},"borrow")," function of the capability:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cadence"},"fun borrow<T: &Any>(): T?\n")),(0,i.kt)("p",{parentName:"li"},"   The function returns a reference to the object targeted by the capability,\nprovided it can be borrowed using the given type."),(0,i.kt)("p",{parentName:"li"},"   ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," is the type parameter for the reference type.\nIf the function is called on a typed capability, the capability's type is used when borrowing.\nIf the capability is untyped, a type argument must be provided explicitly in the call to ",(0,i.kt)("inlineCode",{parentName:"p"},"borrow"),"."),(0,i.kt)("p",{parentName:"li"},"   The function returns ",(0,i.kt)("inlineCode",{parentName:"p"},"nil")," when the targeted path is empty, i.e. nothing is stored under it.\nWhen the requested type exceeds what is allowed by the capability (or any interim capabilities),\nexecution will abort with an error."))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a resource interface named `HasCount`, that has a field `count`\n//\nresource interface HasCount {\n    count: Int\n}\n\n// Declare a resource named `Counter` that conforms to `HasCount`\n//\nresource Counter: HasCount {\n    pub var count: Int\n\n    pub init(count: Int) {\n        self.count = count\n    }\n\n    pub fun increment(by amount: Int) {\n        self.count = self.count + amount\n    }\n}\n\n// In this example an authorized account is available through the constant `authAccount`.\n\n// Create a new instance of the resource type `Counter`\n// and save it in the storage of the account.\n//\n// The path `/storage/counter` is used to refer to the stored value.\n// Its identifier `counter` was chosen freely and could be something else.\n//\nauthAccount.save(<-create Counter(count: 42), to: /storage/counter)\n\n// Create a public capability that allows access to the stored counter object\n// as the type `{HasCount}`, i.e. only the functionality of reading the field\n//\nauthAccount.link<&{HasCount}>(/public/hasCount, target: /storage/counter)\n")),(0,i.kt)("p",null,"To get the published portion of an account, the ",(0,i.kt)("inlineCode",{parentName:"p"},"getAccount")," function can be used."),(0,i.kt)("p",null,"Imagine that the next example is from a different account as before."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cadence"},"\n// Get the public account for the address that stores the counter\n//\nlet publicAccount = getAccount(0x1)\n\n// Get a capability for the counter that is made publicly accessible\n// through the path `/public/hasCount`.\n//\n// Use the type `&{HasCount}`, a reference to some object that provides the functionality\n// of interface `HasCount`. This is the type that the capability can be borrowed as\n// (it was specified in the call to `link` above).\n// See the example below for borrowing using the type `&Counter`.\n//\n// After the call, the declared constant `countCap` has type `Capability<&{HasCount}>`,\n// a capability that results in a reference that has type `&{HasCount}` when borrowed.\n//\nlet countCap = publicAccount.getCapability<&{HasCount}>(/public/hasCount)\n\n// Borrow the capability to get a reference to the stored counter.\n//\n// This borrow succeeds, i.e. the result is not `nil`,\n// it is a valid reference, because:\n//\n// 1. Dereferencing the path chain results in a stored object\n//    (`/public/hasCount` links to `/storage/counter`,\n//    and there is an object stored under `/storage/counter`)\n//\n// 2. The stored value is a subtype of the requested type `{HasCount}`\n//    (the stored object has type `Counter` which conforms to interface `HasCount`)\n//\nlet countRef = countCap.borrow()!\n\ncountRef.count  // is `42`\n\n// Invalid: The `increment` function is not accessible for the reference,\n// because it has the type `&{HasCount}`, which does not expose an `increment` function,\n// only a `count` field\n//\ncountRef.increment(by: 5)\n\n// Again, attempt to get a get a capability for the counter, but use the type `&Counter`.\n//\n// Getting the capability succeeds, because it is latent, but borrowing fails\n// (the result s `nil`), because the capability was created/linked using the type `&{HasCount}`:\n//\n// The resource type `Counter` implements the resource interface `HasCount`,\n// so `Counter` is a subtype of `{HasCount}`, but the capability only allows\n// borrowing using unauthorized references of `{HasCount}` (`&{HasCount}`)\n// instead of authorized references (`auth &{HasCount}`),\n// so users of the capability are not allowed to borrow using subtypes,\n// and they can't escalate the type by casting the reference either.\n//\n// This shows how parts of the functionality of stored objects\n// can be safely exposed to other code\n//\nlet countCapNew = publicAccount.getCapability<&Counter>(/public/hasCount)\nlet counterRefNew = countCapNew.borrow()\n\n// `counterRefNew` is `nil`, the borrow failed\n\n// Invalid: Cannot access the counter object in storage directly,\n// the `borrow` function is not available for public accounts\n//\nlet counterRef2 = publicAccount.borrow<&Counter>(from: /storage/counter)\n")),(0,i.kt)("p",null,"The address of a capability can be obtained from the ",(0,i.kt)("inlineCode",{parentName:"p"},"address")," field of the capability:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cadence"},"let address: Address\n")),(0,i.kt)("p",{parentName:"li"},"   The address of the capability."))))}h.isMDXComponent=!0}}]);