"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[6893],{3905:(n,t,e)=>{e.d(t,{Zo:()=>r,kt:()=>g});var i=e(67294);function a(n,t,e){return t in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function o(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,i)}return e}function c(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?o(Object(e),!0).forEach((function(t){a(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):o(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}function l(n,t){if(null==n)return{};var e,i,a=function(n,t){if(null==n)return{};var e,i,a={},o=Object.keys(n);for(i=0;i<o.length;i++)e=o[i],t.indexOf(e)>=0||(a[e]=n[e]);return a}(n,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);for(i=0;i<o.length;i++)e=o[i],t.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(n,e)&&(a[e]=n[e])}return a}var u=i.createContext({}),s=function(n){var t=i.useContext(u),e=t;return n&&(e="function"==typeof n?n(t):c(c({},t),n)),e},r=function(n){var t=s(n.components);return i.createElement(u.Provider,{value:t},n.children)},d="mdxType",h={inlineCode:"code",wrapper:function(n){var t=n.children;return i.createElement(i.Fragment,{},t)}},p=i.forwardRef((function(n,t){var e=n.components,a=n.mdxType,o=n.originalType,u=n.parentName,r=l(n,["components","mdxType","originalType","parentName"]),d=s(e),p=a,g=d["".concat(u,".").concat(p)]||d[p]||h[p]||o;return e?i.createElement(g,c(c({ref:t},r),{},{components:e})):i.createElement(g,c({ref:t},r))}));function g(n,t){var e=arguments,a=t&&t.mdxType;if("string"==typeof n||a){var o=e.length,c=new Array(o);c[0]=p;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=n,l[d]="string"==typeof n?n:a,c[1]=l;for(var s=2;s<o;s++)c[s]=e[s];return i.createElement.apply(null,c)}return i.createElement.apply(null,e)}p.displayName="MDXCreateElement"},41508:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>u,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var i=e(87462),a=(e(67294),e(3905));const o={title:"Linking Accounts"},c=void 0,l={unversionedId:"hybrid-custody/guides/linking-accounts",id:"hybrid-custody/guides/linking-accounts",title:"Linking Accounts",description:"If you\u2019ve built dApps on Flow, or any blockchain for that matter, you\u2019re painfully aware of the user onboarding process and successive pain of prompting user signatures for on-chain interactions. As a developer, this leaves you with two options - custody the user\u2019s private key and act on their behalf or go with the Web3 status quo, hope your new users are native to Flow and authenticate them via their existing wallet. Either choice will force significant compromise, fragmenting user experience and leaving much to be desired compared to the broader status quo of Web2 identity authentication and single-click onboarding flow.",source:"@site/docs/hybrid-custody/guides/linking-accounts.md",sourceDirName:"hybrid-custody/guides",slug:"/hybrid-custody/guides/linking-accounts",permalink:"/hybrid-custody/guides/linking-accounts",draft:!1,tags:[],version:"current",lastUpdatedBy:"Tom Haile",lastUpdatedAt:1682618007,formattedLastUpdatedAt:"Apr 27, 2023",frontMatter:{title:"Linking Accounts"},sidebar:"tutorialSidebar",previous:{title:"Account Model & Implementation",permalink:"/hybrid-custody/guides/account-model"},next:{title:"Walletless Onboarding",permalink:"/hybrid-custody/guides/walletless-onboarding"}},u={},s=[{value:"Account Linking",id:"account-linking",level:2},{value:"Linking Accounts",id:"linking-accounts",level:2},{value:"Walletless Onboarding",id:"walletless-onboarding",level:2},{value:"Account Creation",id:"account-creation",level:3},{value:"Blockchain-Native Onboarding",id:"blockchain-native-onboarding",level:2},{value:"Account Creation &amp; Linking",id:"account-creation--linking",level:3},{value:"Multisig Transaction",id:"multisig-transaction",level:3},{value:"Publish &amp; Claim",id:"publish--claim",level:2},{value:"Publish",id:"publish",level:3},{value:"Claim",id:"claim",level:3},{value:"DApp-Funded, DApp-Custodied",id:"dapp-funded-dapp-custodied",level:2},{value:"DApp-Funded, User-Custodied",id:"dapp-funded-user-custodied",level:2},{value:"User-Funded, DApp-Custodied",id:"user-funded-dapp-custodied",level:2},{value:"User-Funded, User-Custodied",id:"user-funded-user-custodied",level:2}],r={toc:s},d="wrapper";function h(n){let{components:t,...o}=n;return(0,a.kt)(d,(0,i.Z)({},r,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"If you\u2019ve built dApps on Flow, or any blockchain for that matter, you\u2019re painfully aware of the user onboarding process and successive pain of prompting user signatures for on-chain interactions. As a developer, this leaves you with two options - custody the user\u2019s private key and act on their behalf or go with the Web3 status quo, hope your new users are native to Flow and authenticate them via their existing wallet. Either choice will force significant compromise, fragmenting user experience and leaving much to be desired compared to the broader status quo of Web2 identity authentication and single-click onboarding flow."),(0,a.kt)("p",null,"In this doc, we\u2019ll dive into a progressive onboarding flow, including the Cadence scripts & transactions that go into its implementation in your dApp. These components will enable any implementing dApp to create a custodial account, intermediate the user\u2019s on-chain actions on their behalf, and later delegate control of that dApp-created account to the user\u2019s wallet-mediated account. We\u2019ll refer to this custodial pattern as the Hybrid Account Model and the process of delegating control of the dApp account as Account Linking."),(0,a.kt)("h1",{id:"objectives"},"Objectives"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Establish a ",(0,a.kt)("a",{parentName:"li",href:"https://flow.com/post/flow-blockchain-mainstream-adoption-easy-onboarding-wallets"},"walletless onboarding flow")),(0,a.kt)("li",{parentName:"ul"},"Create a blockchain-native onboarding flow"),(0,a.kt)("li",{parentName:"ul"},"Link an existing app account as a child to a newly authenticated parent account"),(0,a.kt)("li",{parentName:"ul"},"Get your dApp to recognize \u201cparent\u201d accounts along with any associated \u201cchild\u201d accounts"),(0,a.kt)("li",{parentName:"ul"},"View Fungible and NonFungible Token metadata relating to assets across all of a user\u2019s associated accounts - their wallet-mediated \u201cparent\u201d account and any hybrid custody model \u201cchild\u201d accounts"),(0,a.kt)("li",{parentName:"ul"},"Facilitate transactions acting on assets in child accounts")),(0,a.kt)("h1",{id:"point-of-clarity"},"Point of Clarity"),(0,a.kt)("p",null,"Before diving in, let's make a distinction between ",(0,a.kt)("strong",{parentName:"p"},'"account linking"')," and ",(0,a.kt)("strong",{parentName:"p"},'"linking accounts"'),"."),(0,a.kt)("h2",{id:"account-linking"},"Account Linking"),(0,a.kt)("p",null,"Very simply, account linking is a ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/onflow/flips/pull/53"},"feature in Cadence")," that let's an ",(0,a.kt)("a",{parentName:"p",href:"https://developers.flow.com/cadence/language/accounts#authaccount"},"AuthAccount")," create a ",(0,a.kt)("a",{parentName:"p",href:"https://developers.flow.com/cadence/language/capability-based-access-control"},"Capability")," on itself. You can do so in the following transaction:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'#allowAccountLinking\n\ntransaction(linkPathSuffix: String) {\n    prepare(signer: AuthAccount) {\n        // Create the PrivatePath where we\'ll create the link\n        let linkPath = PrivatePath(identifier: linkPathSuffix)\n            ?? panic("Could not construct PrivatePath from given identifier: ".concat(linkPathSuffix))\n        // Check if an AuthAccount Capability already exists at the specified path\n        if !signer.getCapability<&AuthAccount>(linkPath).check() {\n            // If not, unlink anything that may be there and link the AuthAccount Capability\n            signer.unlink(linkpath)\n            signer.linkAccount(linkPath)\n        }\n    }\n}\n')),(0,a.kt)("p",null,"From there, the signing account can retrieve the privately linked AuthAccount Capability and delegate it to another account, unlinking the Capability if they wish to revoke delegated access."),(0,a.kt)("p",null,"Note that in order to link an account, a transaction must state the ",(0,a.kt)("inlineCode",{parentName:"p"},"#allowAccountLinking")," as a pragme in the top line of the transaction. This is an interim safety measure so that wallet providers can notify users they're about to sign a transaction that may create and use a Capability on their AuthAccount."),(0,a.kt)("h2",{id:"linking-accounts"},"Linking Accounts"),(0,a.kt)("p",null,"Linking accounts uses an account link, otherwise known as an ",(0,a.kt)("strong",{parentName:"p"},"AuthAccount Capability"),", and encapsulates it in an object that is then kept in the a collection of linked account. The ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/onflow/flips/pull/72"},"components and actions")," involved in this process - what the Capabity is encapsulated in, the collection that holds those encapsulations, etc. is what we'll dive into in this doc."),(0,a.kt)("h1",{id:"terminology"},"Terminology"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Parent-Child accounts")," - For the moment, we\u2019ll call the account created by the dApp the \u201cchild\u201d account and the account receiving its AuthAccount Capability the \u201cparent\u201d account. Existing methods of account access & delegation (i.e. keys) still imply ownership over the account, but insofar as linked accounts are concerned, the account to which both the user and the dApp share access via AuthAccount Capability will be considered the \u201cchild\u201d account. This naming is a topic of community discussion and may be subject to change."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Walletless onboarding")," - An onboarding flow whereby a dApp creates an account for a user, onboarding them to the dApp, obviating the need for user wallet authentication."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Blockchain-native onboarding")," - Similar to the already familiar Web3 onboarding flow where a user authenticates with their existing wallet, a dApp onboards a user via wallet authentication while additionally creating a dApp account and linking it with the authenticated account, resulting in a hybrid custody model."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Hybrid Custody Model")," - A custodial pattern in which a dApp and a user maintain access to a dApp created account and user access to that account has been mediated by account linking."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Account Linking")," - Technically speaking, account linking in our context consists of giving some other account an AuthAccount Capability from the granting account. This Capability is maintained in (soon to be standard) resource called a ",(0,a.kt)("inlineCode",{parentName:"p"},"LinkedAccounts.Collection"),", providing its owning user access to any and all of their linked accounts."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Progressive Onboarding")," - An onboarding flow that walks a user up to self-custodial ownership, starting with walletless onboarding and later linking the dApp account with the user\u2019s authenticated wallet once the user chooses to do so."),(0,a.kt)("h1",{id:"onboarding-flows"},"Onboarding Flows"),(0,a.kt)("p",null,"Given the ability to establish an account and later delegate access to a user, dApps are freed from the constraints of dichotomous custodial & self-custodial patterns. A developer can choose to onboard a user via traditional Web2 identity and later delegate access to the user\u2019s wallet account. Alternatively, a dApp can enable wallet authentication at the outset, creating a dApp specific account & linking with the user\u2019s wallet account. As specified above, these two flows are known as walletless and blockchain-native respectively. Developers can choose to implement one for simplicity or both for user flexibility. "),(0,a.kt)("h2",{id:"walletless-onboarding"},"Walletless Onboarding"),(0,a.kt)("h3",{id:"account-creation"},"Account Creation"),(0,a.kt)("p",null,"The following transaction creates an account, funding creation via the signer and adding the provided public key. You'll notice this transaction is pretty much your standard account creation. The magic for you will be how you custody the key for this account (locally, KMS, wallet service, etc.) in a manner that allows your dapp to mediate on-chain interactions on behalf of your user."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'import FlowToken from "../../contracts/utility/FlowToken.cdc"\nimport FungibleToken from "../../contracts/utility/FungibleToken.cdc"\n\n/// Taken from the onflow/linked-accounts repo\n/// https://github.com/onflow/linked-accounts\n///\ntransaction(\n    pubKey: String,\n    initialFundingAmt: UFix64,\n  ) {\n    \n    prepare(signer: AuthAccount) {\n\n        /* --- Account Creation (your dApp may choose to separate creation depending on your custodial model) --- */\n        //\n        // Create the child account, funding via the signer\n        let newAccount = AuthAccount(payer: signer)\n        // Create a public key for the proxy account from string value in the provided arg\n        // **NOTE:** You may want to specify a different signature algo for your use case\n        let key = PublicKey(\n            publicKey: pubKey.decodeHex(),\n            signatureAlgorithm: SignatureAlgorithm.ECDSA_P256\n        )\n        // Add the key to the new account\n        // **NOTE:** You may want to specify a different hash algo & weight best for your use case\n        newAccount.keys.add(\n            publicKey: key,\n            hashAlgorithm: HashAlgorithm.SHA3_256,\n            weight: 1000.0\n        )\n\n        /* --- (Optional) Additional Account Funding --- */\n        //\n        // Fund the new account if specified\n        if initialFundingAmt > 0.0 {\n            // Get a vault to fund the new account\n            let fundingProvider = signer.borrow<&FlowToken.Vault{FungibleToken.Provider}>(\n                    from: /storage/flowTokenVault\n                )!\n            // Fund the new account with the initialFundingAmount specified\n            newAccount.getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(\n                /public/flowTokenReceiver\n            ).borrow()!\n            .deposit(\n                from: <-fundingProvider.withdraw(\n                    amount: initialFundingAmt\n                )\n            )\n        }\n\n        /* Continue with use case specific setup */\n        //\n        // At this point, the newAccount can further be configured as suitable for\n        // use in your dapp (e.g. Setup a Collection, Mint NFT, Configure Vault, etc.)\n        // ...\n    }\n}\n')),(0,a.kt)("h2",{id:"blockchain-native-onboarding"},"Blockchain-Native Onboarding"),(0,a.kt)("p",null,"Compared to walletless onboarding where a user does not have a Flow account, blockchain-native onboarding assumes a user already has a wallet configured and immediately links it with a newly created dApp account. This enables the dApp to sign transactions on the user's behalf via the new child account while immediately delegating control of that account to the onboarding user's main account."),(0,a.kt)("p",null,"After this transaction, both the custodial party (presumably the client/dApp) and the signing parent account will have access to the newly created account - the custodial party via key access and the parent account via their ",(0,a.kt)("inlineCode",{parentName:"p"},"LinkedAccounts.Collection")," maintaining the new account's AuthAccount Capability."),(0,a.kt)("h3",{id:"account-creation--linking"},"Account Creation & Linking"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'#allowAccountLinking\n\nimport FungibleToken from "../../contracts/utility/FungibleToken.cdc"\nimport FlowToken from "../../contracts/utility/FlowToken.cdc"\nimport MetadataViews from "../../contracts/utility/MetadataViews.cdc"\nimport NonFungibleToken from "../../contracts/utility/NonFungibleToken.cdc"\nimport LinkedAccountMetadataViews from "../../contracts/LinkedAccountMetadataViews.cdc"\nimport LinkedAccounts from "../../contracts/LinkedAccounts.cdc"\n\n/// Taken from the onflow/linked-accounts repo\n/// https://github.com/onflow/linked-accounts\n///\ntransaction(\n    pubKey: String,\n    fundingAmt: UFix64,\n    linkedAccountName: String,\n    linkedAccountDescription: String,\n    clientThumbnailURL: String,\n    clientExternalURL: String,\n    authAccountPathSuffix: String,\n    handlerPathSuffix: String\n  ) {\n\n    let collectionRef: &LinkedAccounts.Collection\n    let info: LinkedAccountMetadataViews.AccountInfo\n    let authAccountCap: Capability<&AuthAccount>\n    let newAccountAddress: Address\n    \n    prepare(parent: AuthAccount, client: AuthAccount) {\n        \n        /* --- Account Creation (your dApp may choose to handle creation differently depending on your custodial model) --- */\n        //\n        // Create the child account, funding via the signer\n        let newAccount = AuthAccount(payer: client)\n        // Create a public key for the proxy account from string value in the provided arg\n        // **NOTE:** You may want to specify a different signature algo for your use case\n        let key = PublicKey(\n            publicKey: pubKey.decodeHex(),\n            signatureAlgorithm: SignatureAlgorithm.ECDSA_P256\n        )\n        // Add the key to the new account\n        // **NOTE:** You may want to specify a different hash algo & weight best for your use case\n        newAccount.keys.add(\n            publicKey: key,\n            hashAlgorithm: HashAlgorithm.SHA3_256,\n            weight: 1000.0\n        )\n\n        /* (Optional) Additional Account Funding */\n        //\n        // Fund the new account if specified\n        if fundingAmt > 0.0 {\n            // Get a vault to fund the new account\n            let fundingProvider = client.borrow<&FlowToken.Vault{FungibleToken.Provider}>(\n                    from: /storage/flowTokenVault\n                )!\n            // Fund the new account with the initialFundingAmount specified\n            newAccount.getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(\n                /public/flowTokenReceiver\n            ).borrow()!\n            .deposit(\n                from: <-fundingProvider.withdraw(\n                    amount: fundingAmt\n                )\n            )\n        }\n        self.newAccountAddress = newAccount.address\n\n        // At this point, the newAccount can further be configured as suitable for\n        // use in your dapp (e.g. Setup a Collection, Mint NFT, Configure Vault, etc.)\n        // ...\n\n        /* --- Setup parent\'s LinkedAccounts.Collection --- */\n        //\n        // Check that Collection is saved in storage\n        if parent.type(at: LinkedAccounts.CollectionStoragePath) == nil {\n            parent.save(\n                <-LinkedAccounts.createEmptyCollection(),\n                to: LinkedAccounts.CollectionStoragePath\n            )\n        }\n        // Link the public Capability\n        if !parent.getCapability<\n                &LinkedAccounts.Collection{LinkedAccounts.CollectionPublic, MetadataViews.ResolverCollection}\n            >(LinkedAccounts.CollectionPublicPath).check() {\n            parent.unlink(LinkedAccounts.CollectionPublicPath)\n            parent.link<&LinkedAccounts.Collection{LinkedAccounts.CollectionPublic, MetadataViews.ResolverCollection}>(\n                LinkedAccounts.CollectionPublicPath,\n                target: LinkedAccounts.CollectionStoragePath\n            )\n        }\n        // Link the private Capability\n        if !parent.getCapability<\n                &LinkedAccounts.Collection{LinkedAccounts.CollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, NonFungibleToken.Provider, MetadataViews.ResolverCollection}\n            >(LinkedAccounts.CollectionPrivatePath).check() {\n            parent.unlink(LinkedAccounts.CollectionPrivatePath)\n            parent.link<\n                &LinkedAccounts.Collection{LinkedAccounts.CollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, NonFungibleToken.Provider, MetadataViews.ResolverCollection}\n            >(\n                LinkedAccounts.CollectionPrivatePath,\n                target: LinkedAccounts.CollectionStoragePath\n            )\n        }\n        // Assign a reference to the Collection we now know is correctly configured\n        self.collectionRef = parent.borrow<&LinkedAccounts.Collection>(from: LinkedAccounts.CollectionStoragePath)!\n\n        /* --- Link the child account\'s AuthAccount Capability & assign --- */\n        //\n        // Assign the PrivatePath where we\'ll link the AuthAccount Capability\n        let authAccountPath: PrivatePath = PrivatePath(identifier: authAccountPathSuffix)\n            ?? panic("Could not construct PrivatePath from given suffix: ".concat(authAccountPathSuffix))\n        // Link the new account\'s AuthAccount Capability\n        self.authAccountCap = newAccount.linkAccount(authAccountPath)\n        \n        /** --- Construct metadata --- */\n        //\n        // Construct linked account metadata from given arguments\n        self.info = LinkedAccountMetadataViews.AccountInfo(\n            name: linkedAccountName,\n            description: linkedAccountDescription,\n            thumbnail: MetadataViews.HTTPFile(url: clientThumbnailURL),\n            externalURL: MetadataViews.ExternalURL(clientExternalURL)\n        )\n    }\n\n    execute {\n        /* --- Link the parent & child accounts --- */\n        //\n        // Add the child account\n        self.collectionRef.addAsChildAccount(\n            linkedAccountCap: self.authAccountCap,\n            linkedAccountMetadata: self.info,\n            linkedAccountMetadataResolver: nil,\n            handlerPathSuffix: handlerPathSuffix\n        )\n    }\n\n    post {\n        // Make sure new account was linked to parent\'s successfully\n        self.collectionRef.getLinkedAccountAddresses().contains(self.newAccountAddress):\n            "Problem linking accounts!"\n    }\n}\n\n')),(0,a.kt)("h1",{id:"account-linking-1"},"Account Linking"),(0,a.kt)("p",null,'Linking an account is the process of delegating account access via AuthAccount Capability. Of course, we want to do this in a way that allows the receiving account to maintain that Capability and allows easy identification of the accounts on either end of the linkage - the user\'s main "parent" account and the linked "child" account. This is accomplished in the (still in flux) ',(0,a.kt)("inlineCode",{parentName:"p"},"LinkedAccounts")," contract which we'll continue to use in this guidance."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"\u26a0\ufe0f Note that since account linking is a sensitive action, transactions where an account may be linked are designated by a topline pragma ",(0,a.kt)("inlineCode",{parentName:"p"},"#allowAccountLinking"),". This lets wallet providers inform users that their account may be linked in the signing transaction.")),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"resources/linked-accounts-diagram.jpg",src:e(47362).Z,width:"2676",height:"2247"})),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"In this scenario, a user custodies a key for their main account which has a ",(0,a.kt)("inlineCode",{parentName:"em"},"LinkedAccounts.Collection")," within it. Their ",(0,a.kt)("inlineCode",{parentName:"em"},"LinkedAccounts.NFT")," maintains an AuthAccount Capability to the child account, which the dApp maintains access to via the account\u2019s key and within which a ",(0,a.kt)("inlineCode",{parentName:"em"},"LinkedAccounts.Handler"),".")),(0,a.kt)("p",null,"Linking accounts can be done in one of two ways. Put simply, the child account needs to get the parent account its AuthAccount Capability, and the parent needs to save that Capability in its ",(0,a.kt)("inlineCode",{parentName:"p"},"LinkedAccounts.Collection")," in a manner that represents the linked accounts and their relative associations. We can achieve this in a multisig transaction signed by both the the accounts on either side of the link, or we can leverage Cadence\u2019s ",(0,a.kt)("inlineCode",{parentName:"p"},"AuthAccount.Inbox")," to publish the Capability from the child account & have the parent claim the Capability in a separate transaction. Let\u2019s take a look at both."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"A consideration during the linking process is whether you would like the parent account to be configured with some resources or Capabilities relevant to your dApp. For example, if your dApp deals with specific NFTs, you may want to configure the parent account with Collections for those NFTs so the user can easily transfer them between their linked accounts.")),(0,a.kt)("h3",{id:"multisig-transaction"},"Multisig Transaction"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'#allowAccountLinking\n\nimport MetadataViews from "../../contracts/utility/MetadataViews.cdc"\nimport NonFungibleToken from "../../contracts/utility/NonFungibleToken.cdc"\nimport LinkedAccountMetadataViews from "../../contracts/LinkedAccountMetadataViews.cdc"\nimport LinkedAccounts from "../../contracts/LinkedAccounts.cdc"\n\n/// Links thie signing accounts as labeled, with the child\'s AuthAccount Capability\n/// maintained in the parent\'s LinkedAccounts.Collection\n///\ntransaction(\n    linkedAccountName: String,\n    linkedAccountDescription: String,\n    clientThumbnailURL: String,\n    clientExternalURL: String,\n    authAccountPathSuffix: String,\n    handlerPathSuffix: String\n) {\n\n    let collectionRef: &LinkedAccounts.Collection\n    let info: LinkedAccountMetadataViews.AccountInfo\n    let authAccountCap: Capability<&AuthAccount>\n    let linkedAccountAddress: Address\n\n    prepare(parent: AuthAccount, child: AuthAccount) {\n        \n        /** --- Configure Collection & get ref --- */\n        //\n        // Check that Collection is saved in storage\n        if parent.type(at: LinkedAccounts.CollectionStoragePath) == nil {\n            parent.save(\n                <-LinkedAccounts.createEmptyCollection(),\n                to: LinkedAccounts.CollectionStoragePath\n            )\n        }\n        // Link the public Capability\n        if !parent.getCapability<\n                &LinkedAccounts.Collection{LinkedAccounts.CollectionPublic, MetadataViews.ResolverCollection}\n            >(LinkedAccounts.CollectionPublicPath).check() {\n            parent.unlink(LinkedAccounts.CollectionPublicPath)\n            parent.link<&LinkedAccounts.Collection{LinkedAccounts.CollectionPublic, MetadataViews.ResolverCollection}>(\n                LinkedAccounts.CollectionPublicPath,\n                target: LinkedAccounts.CollectionStoragePath\n            )\n        }\n        // Link the private Capability\n        if !parent.getCapability<\n                &LinkedAccounts.Collection{LinkedAccounts.CollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, NonFungibleToken.Provider, MetadataViews.ResolverCollection}\n            >(LinkedAccounts.CollectionPrivatePath).check() {\n            parent.unlink(LinkedAccounts.CollectionPrivatePath)\n            parent.link<\n                &LinkedAccounts.Collection{LinkedAccounts.CollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, NonFungibleToken.Provider, MetadataViews.ResolverCollection}\n            >(\n                LinkedAccounts.CollectionPrivatePath,\n                target: LinkedAccounts.CollectionStoragePath\n            )\n        }\n        // Get Collection reference from signer\n        self.collectionRef = parent.borrow<\n                &LinkedAccounts.Collection\n            >(\n                from: LinkedAccounts.CollectionStoragePath\n            )!\n\n        /* --- Link the child account\'s AuthAccount Capability & assign --- */\n        //\n        // Assign the PrivatePath where we\'ll link the AuthAccount Capability\n        let authAccountPath: PrivatePath = PrivatePath(identifier: authAccountPathSuffix)\n            ?? panic("Could not construct PrivatePath from given suffix: ".concat(authAccountPathSuffix))\n        // Get the AuthAccount Capability, linking if necessary\n        if !child.getCapability<&AuthAccount>(authAccountPath).check() {\n            // Unlink any Capability that may be there\n            child.unlink(authAccountPath)\n            // Link & assign the AuthAccount Capability\n            self.authAccountCap = child.linkAccount(authAccountPath)!\n        } else {\n            // Assign the AuthAccount Capability\n            self.authAccountCap = child.getCapability<&AuthAccount>(authAccountPath)\n        }\n        self.linkedAccountAddress = self.authAccountCap.borrow()?.address ?? panic("Problem with retrieved AuthAccount Capability")\n\n        /** --- Construct metadata --- */\n        //\n        // Construct linked account metadata from given arguments\n        self.info = LinkedAccountMetadataViews.AccountInfo(\n            name: linkedAccountName,\n            description: linkedAccountDescription,\n            thumbnail: MetadataViews.HTTPFile(url: clientThumbnailURL),\n            externalURL: MetadataViews.ExternalURL(clientExternalURL)\n        )\n    }\n\n    execute {\n        // Add child account if it\'s parent-child accounts aren\'t already linked\n        if !self.collectionRef.getLinkedAccountAddresses().contains(self.linkedAccountAddress) {\n            // Add the child account\n            self.collectionRef.addAsChildAccount(\n                linkedAccountCap: self.authAccountCap,\n                linkedAccountMetadata: self.info,\n                linkedAccountMetadataResolver: nil,\n                handlerPathSuffix: handlerPathSuffix\n            )\n        }\n    }\n\n    post {\n        self.collectionRef.getLinkedAccountAddresses().contains(self.linkedAccountAddress):\n            "Problem linking accounts!"\n    }\n}\n\n')),(0,a.kt)("h2",{id:"publish--claim"},"Publish & Claim"),(0,a.kt)("h3",{id:"publish"},"Publish"),(0,a.kt)("p",null,"Here, the account delegating access to itself links its AuthAccount Capability, and publishes it to be claimed by the account it will be linked to."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'#allowAccountLinking\n\n/// Signing account publishes a Capability to its AuthAccount for\n/// the specified parentAddress to claim\n///\ntransaction(parentAddress: Address, authAccountPathSuffix: String) {\n\n    let authAccountCap: Capability<&AuthAccount>\n\n    prepare(signer: AuthAccount) {\n        // Assign the PrivatePath where we\'ll link the AuthAccount Capability\n        let authAccountPath: PrivatePath = PrivatePath(identifier: authAccountPathSuffix)\n            ?? panic("Could not construct PrivatePath from given suffix: ".concat(authAccountPathSuffix))\n        // Get the AuthAccount Capability, linking if necessary\n        if !signer.getCapability<&AuthAccount>(authAccountPath).check() {\n            signer.unlink(authAccountPath)\n            self.authAccountCap = signer.linkAccount(authAccountPath)!\n        } else {\n            self.authAccountCap = signer.getCapability<&AuthAccount>(authAccountPath)\n        }\n        // Publish for the specified Address\n        signer.inbox.publish(self.authAccountCap!, name: "AuthAccountCapability", recipient: parentAddress)\n    }\n}\n')),(0,a.kt)("h3",{id:"claim"},"Claim"),(0,a.kt)("p",null,"On the other side, the receiving account claims the published AuthAccount Capability, adding it to the signer's ",(0,a.kt)("inlineCode",{parentName:"p"},"LinkedAccounts.Collection"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'import MetadataViews from "../../contracts/utility/MetadataViews.cdc"\nimport NonFungibleToken from "../../contracts/utility/NonFungibleToken.cdc"\nimport LinkedAccountMetadataViews from "../../contracts/LinkedAccountMetadataViews.cdc"\nimport LinkedAccounts from "../../contracts/LinkedAccounts.cdc"\n\n/// Signing account claims a Capability to specified Address\'s AuthAccount\n/// and adds it as a child account in its LinkedAccounts.Collection, allowing it \n/// to maintain the claimed Capability\n///\ntransaction(\n        linkedAccountAddress: Address,\n        linkedAccountName: String,\n        linkedAccountDescription: String,\n        clientThumbnailURL: String,\n        clientExternalURL: String,\n        handlerPathSuffix: String\n    ) {\n\n    let collectionRef: &LinkedAccounts.Collection\n    let info: LinkedAccountMetadataViews.AccountInfo\n    let authAccountCap: Capability<&AuthAccount>\n\n    prepare(signer: AuthAccount) {\n        /** --- Configure Collection & get ref --- */\n        //\n        // Check that Collection is saved in storage\n        if signer.type(at: LinkedAccounts.CollectionStoragePath) == nil {\n            signer.save(\n                <-LinkedAccounts.createEmptyCollection(),\n                to: LinkedAccounts.CollectionStoragePath\n            )\n        }\n        // Link the public Capability\n        if !signer.getCapability<\n                &LinkedAccounts.Collection{LinkedAccounts.CollectionPublic, MetadataViews.ResolverCollection}\n            >(LinkedAccounts.CollectionPublicPath).check() {\n            signer.unlink(LinkedAccounts.CollectionPublicPath)\n            signer.link<&LinkedAccounts.Collection{LinkedAccounts.CollectionPublic, MetadataViews.ResolverCollection}>(\n                LinkedAccounts.CollectionPublicPath,\n                target: LinkedAccounts.CollectionStoragePath\n            )\n        }\n        // Link the private Capability\n        if !signer.getCapability<\n                &LinkedAccounts.Collection{LinkedAccounts.CollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, NonFungibleToken.Provider, MetadataViews.ResolverCollection}\n            >(LinkedAccounts.CollectionPrivatePath).check() {\n            signer.unlink(LinkedAccounts.CollectionPrivatePath)\n            signer.link<\n                &LinkedAccounts.Collection{LinkedAccounts.CollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, NonFungibleToken.Provider, MetadataViews.ResolverCollection}\n            >(\n                LinkedAccounts.CollectionPrivatePath,\n                target: LinkedAccounts.CollectionStoragePath\n            )\n        }\n        // Get Collection reference from signer\n        self.collectionRef = signer.borrow<\n                &LinkedAccounts.Collection\n            >(\n                from: LinkedAccounts.CollectionStoragePath\n            )!\n        \n        /** --- Prep to link account --- */\n        //\n        // Claim the previously published AuthAccount Capability from the given Address\n        self.authAccountCap = signer.inbox.claim<&AuthAccount>(\n                "AuthAccountCapability",\n                provider: linkedAccountAddress\n            ) ?? panic(\n                "No AuthAccount Capability available from given provider"\n                .concat(linkedAccountAddress.toString())\n                .concat(" with name ")\n                .concat("AuthAccountCapability")\n            )\n        \n        /** --- Construct metadata --- */\n        //\n        // Construct linked account metadata from given arguments\n        self.info = LinkedAccountMetadataViews.AccountInfo(\n            name: linkedAccountName,\n            description: linkedAccountDescription,\n            thumbnail: MetadataViews.HTTPFile(url: clientThumbnailURL),\n            externalURL: MetadataViews.ExternalURL(clientExternalURL)\n        )\n    }\n\n    execute {\n        // Add account as child to the signer\'s LinkedAccounts.Collection\n        self.collectionRef.addAsChildAccount(\n            linkedAccountCap: self.authAccountCap,\n            linkedAccountMetadata: self.info,\n            linkedAccountMetadataResolver: nil,\n            handlerPathSuffix: handlerPathSuffix\n        )\n    }\n}\n \n')),(0,a.kt)("h1",{id:"funding--custody-patterns"},"Funding & Custody Patterns"),(0,a.kt)("p",null,"Aside from implementing onboarding flows & account linking, you'll want to also consider the account funding & custodial pattern appropriate for the dApp you're building. The only one compatible with walletless onboarding (and therefore the only one showcased above) is one in which the dApp custodies the child account's key and funds account creation."),(0,a.kt)("p",null,"In general, the funding pattern for account creation will determine to some extent the backend infrastructure needed to support your dApp and the onboarding flow your dApp can support. For example, if you want to to create a service-less client (a totally local dApp without backend infrastructure), you could forego walletless onboarding in favor of a user-funded blockchain-native onboarding to achieve a hybrid custody model. Your dApp maintains the keys to the dApp account to sign on behalf of the user, and the user funds the creation of the the account, linking to their main account on account creation. This would be a ",(0,a.kt)("strong",{parentName:"p"},"user-funded, dApp custodied")," pattern."),(0,a.kt)("p",null,"Again, custody may deserve some regulatory insight depending on your jurisdiction. If building for production, you'll likely want to consider these non-technical implications in your technical decision-making. Such is the nature of building in crypto..."),(0,a.kt)("p",null,"Here are the patterns you might consider:"),(0,a.kt)("h2",{id:"dapp-funded-dapp-custodied"},"DApp-Funded, DApp-Custodied"),(0,a.kt)("p",null,"If you want to implement walletless onboarding, you can stop here as this is the only compatible pattern. In this scenario, a backend dApp account funds the creation of a new account and the dApp custodies the key for said account either on the user's device or some backend KMS."),(0,a.kt)("h2",{id:"dapp-funded-user-custodied"},"DApp-Funded, User-Custodied"),(0,a.kt)("p",null,"In this case, the backend dApp account funds account creation, but adds a key to the account which the user custodies. In order for the dApp to act on the user's behalf, it has to be delegated access via AuthAccount Capability which the backend dApp account would maintain in a ",(0,a.kt)("inlineCode",{parentName:"p"},"LinkedAccounts.Collection"),". This means that the new account would have two parent accounts - the user's and the dApp. While not comparatively useful now, once ",(0,a.kt)("a",{parentName:"p",href:"https://forum.onflow.org/t/super-user-account/4088"},(0,a.kt)("inlineCode",{parentName:"a"},"SuperAuthAccount"))," is ironed out and implemented, this pattern will be the most secure in that the custodying user will have ultimate authority over the child account. Also note that this and the following patterns are incompatible with walletless onboarding in that the user must have a wallet."),(0,a.kt)("h2",{id:"user-funded-dapp-custodied"},"User-Funded, DApp-Custodied"),(0,a.kt)("p",null,"As mentioned above, this pattern unlocks totally service-less architectures - just a local client & smart contracts. An authenticated user signs a transaction creating an account, adding the key provided by the client, and linking the account as a child account. At the end of the transaction, hybrid custody is achieved and the dApp can sign with the custodied key on the user's behalf using the newly created account."),(0,a.kt)("h2",{id:"user-funded-user-custodied"},"User-Funded, User-Custodied"),(0,a.kt)("p",null,"While perhaps not useful for most dApps, this pattern may be desirable for advanced users who wish to create a shared access account themselves. The user funds account creation, adding keys they custody, and delegates secondary access to some other account. As covered above in account linking, this can be done via multisig or the publish & claim mechanism."),(0,a.kt)("h1",{id:"additional-resources"},"Additional Resources"),(0,a.kt)("p",null,"You can find additional Cadence examples in context at the following repos:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/onflow/linked-accounts"},"LinkedAccounts contract & supporting scripts & transactions")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/onflow/sc-eng-gaming/tree/sisyphusSmiling/child-account-auth-acct-cap"},"Using ChildAccount paradigm in an on-chain Rock, Paper, Scissors game"))))}h.isMDXComponent=!0},47362:(n,t,e)=>{e.d(t,{Z:()=>i});const i=e.p+"assets/images/linked-accounts-diagram-f661c11d238d62ff6d5009edcb51be0f.jpg"}}]);