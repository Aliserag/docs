"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[4903],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>f});var o=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=o.createContext({}),l=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return o.createElement(c.Provider,{value:t},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),h=l(n),p=r,f=h["".concat(c,".").concat(p)]||h[p]||d[p]||a;return n?o.createElement(f,i(i({ref:t},u),{},{components:n})):o.createElement(f,i({ref:t},u))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=p;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[h]="string"==typeof e?e:r,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}p.displayName="MDXCreateElement"},37468:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var o=n(87462),r=(n(67294),n(3905));const a={title:"Transactions"},i=void 0,s={unversionedId:"1.Learn/Concepts/transactions",id:"1.Learn/Concepts/transactions",title:"Transactions",description:"Transaction Journey",source:"@site/docs/1.Learn/Concepts/transactions.mdx",sourceDirName:"1.Learn/Concepts",slug:"/1.Learn/Concepts/transactions",permalink:"/1.Learn/Concepts/transactions",draft:!1,tags:[],version:"current",lastUpdatedBy:"Tom Haile",lastUpdatedAt:1682541550,formattedLastUpdatedAt:"Apr 26, 2023",frontMatter:{title:"Transactions"},sidebar:"tutorialSidebar",previous:{title:"Signing a Transaction",permalink:"/1.Learn/Concepts/transaction-signing"},next:{title:"Segmented Transaction Fees",permalink:"/1.Learn/Concepts/variable-transaction-fees"}},c={},l=[{value:"Transaction Journey",id:"transaction-journey",level:2}],u={toc:l},h="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(h,(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"transaction-journey"},"Transaction Journey"),(0,r.kt)("p",null,"A Transaction is the smallest unit of computation performed by the Flow network. Each transaction includes a short script for updating the execution state (which can call methods defined in smart contracts) and includes one or more cryptographic signatures used to authenticate the authority of the submitter. A User Agent (often called \u201cwallet software\u201d) is responsible for forming transactions and transmitting them to Flow."),(0,r.kt)("p",null,"When a transaction is ready, a user agent submits the transaction to a collection node. The collection node validates the transaction and then shares it with other nodes inside the cluster. The cluster forms a collection containing the transaction, aggregates a set of signatures from a supermajority of cluster members, and then forwards the collection guarantee to the consensus nodes. A collection guarantee contains a hash derived from the contents of all transactions, the cluster id which created the collection, the count of transactions in the collection, and the signatures of collection nodes committing to the collection. By signing a collection, a collection node is responsible to store and hold on to a collection and respond to queries. A collection node only receives a reward for the collections it signs."),(0,r.kt)("p",null,"Consensus nodes are responsible for forming blocks containing collection guarantees. Finalized blocks are transmitted to execution nodes who then contact the collection nodes that guaranteed each collection for the contents of those collections."),(0,r.kt)("p",null,"Upon receiving the content of all collections in a block, the execution nodes run the transactions referenced from that block and broadcast an Execution Receipt. The execution receipt includes a hashed commitment of the execution state resulting from correctly applying the state transitions specified in the complete transaction set for that block, plus cryptographic commitments to interim execution states at specific milestones through the block."),(0,r.kt)("p",null,"Consensus nodes include those execution receipts in new blocks; after a block containing an execution receipt is finalized, the verification nodes start checking the correctness of the individual parts of the execution work included in the block, by recreating the transition from one interim milestone to the next. The random beacon value from the block including the transaction receipt is used to seed a deterministic assignment algorithm. This algorithm randomly assigns a region of the computation between two milestones (a chunk) to a set of verification nodes. Every chunk is assigned a number of verifiers derived from the size of the verification pool and the number of chunks in the block (this analysis assumes 50 verifiers for each chunk, and 1,000 chunks in each block)."),(0,r.kt)("p",null,"In order to verify a chunk, a verification node contacts an execution node for the input data (chunk data package) matching the appropriate milestone for their chunk from the execution receipt. If the verification node confirms that the transition from one milestone to the next is correct for that chunk it broadcasts a Result Approval to the consensus nodes; if it finds an error, it instead broadcasts a Faulty Computation Challenge (FCC)."),(0,r.kt)("p",null,"If the consensus nodes receive sufficient result approvals for all chunks in an execution receipt, they will include a Result Seal for that receipt in the next new block. At least \u2154 of the validators assigned to each chunk must positively provide result approvals for a result to be sealed. If one or more chunks don\u2019t receive enough result approvals for sealing after several blocks have passed, the consensus nodes trigger Full Check Mode for those chunks. In full check mode, all verification nodes are asked to check the chunks in question. Full check mode requires \u2154 of all validators to respond with result approvals to seal the result. Full check mode is also triggered if the execution nodes provide two or more different execution receipts for the same block."),(0,r.kt)("p",null,"When a result is sealed, the output of all corresponding transactions are finalized and the changes are not reversible."))}d.isMDXComponent=!0}}]);