"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[2033],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>h});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var o=a.createContext({}),c=function(e){var n=a.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},d=function(e){var n=c(e.components);return a.createElement(o.Provider,{value:n},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(t),m=i,h=u["".concat(o,".").concat(m)]||u[m]||p[m]||r;return t?a.createElement(h,l(l({ref:n},d),{},{components:t})):a.createElement(h,l({ref:n},d))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,l=new Array(r);l[0]=m;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s[u]="string"==typeof e?e:i,l[1]=s;for(var c=2;c<r;c++)l[c]=t[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},30676:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=t(87462),i=(t(67294),t(3905));const r={title:"Contract Updatability"},l=void 0,s={unversionedId:"cadence/language/contract-updatability",id:"cadence/language/contract-updatability",title:"Contract Updatability",description:"Introduction",source:"@site/docs/cadence/language/contract-updatability.md",sourceDirName:"cadence/language",slug:"/cadence/language/contract-updatability",permalink:"/cadence/language/contract-updatability",draft:!1,tags:[],version:"current",lastUpdatedBy:"Tom Haile",lastUpdatedAt:1682541550,formattedLastUpdatedAt:"Apr 26, 2023",frontMatter:{title:"Contract Updatability"},sidebar:"tutorialSidebar",previous:{title:"Constants and Variable Declarations",permalink:"/cadence/language/constants-and-variables"},next:{title:"Contracts",permalink:"/cadence/language/contracts"}},o={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Validation Goals",id:"validation-goals",level:2},{value:"Updating a Contract",id:"updating-a-contract",level:2},{value:"Valid Changes",id:"valid-changes",level:4},{value:"Invalid Changes",id:"invalid-changes",level:4},{value:"Contract Fields",id:"contract-fields",level:3},{value:"Nested Declarations",id:"nested-declarations",level:3},{value:"Fields",id:"fields",level:2},{value:"Valid Changes:",id:"valid-changes-1",level:4},{value:"Invalid Changes:",id:"invalid-changes-1",level:4},{value:"Updating Members",id:"updating-members",level:3},{value:"Enums",id:"enums",level:2},{value:"Valid Changes:",id:"valid-changes-2",level:4},{value:"Invalid Changes:",id:"invalid-changes-2",level:4},{value:"Invalid Changes",id:"invalid-changes-3",level:4},{value:"Functions",id:"functions",level:2},{value:"Constructors",id:"constructors",level:2},{value:"Imports",id:"imports",level:2}],d={toc:c},u="wrapper";function p(e){let{components:n,...t}=e;return(0,i.kt)(u,(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"contracts"},"contract")," in Cadence is a collection of data (its state) and\ncode (its functions) that lives in the contract storage area of an account.\nWhen a contract is updated, it is important to make sure that the changes introduced do not lead to runtime\ninconsistencies for already stored data.\nCadence maintains this state consistency by validating the contracts and all their components before an update."),(0,i.kt)("h2",{id:"validation-goals"},"Validation Goals"),(0,i.kt)("p",null,"The contract update validation ensures that:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Stored data doesn't change its meaning when a contract is updated."),(0,i.kt)("li",{parentName:"ul"},"Decoding and using stored data does not lead to runtime crashes.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"For example, it is invalid to add a field because existing stored data won't have the new field."),(0,i.kt)("li",{parentName:"ul"},"Loading the existing data will result in garbage/missing values for such fields."),(0,i.kt)("li",{parentName:"ul"},"A static check of the access of the field would be valid, but the interpreter would crash when accessing the field,\nbecause the field has a missing/garbage value.")))),(0,i.kt)("p",null,"However, it ",(0,i.kt)("strong",{parentName:"p"},"does not")," ensure:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Any program that imports the updated contract stays valid. e.g:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Updated contract may remove an existing field or may change a function signature."),(0,i.kt)("li",{parentName:"ul"},"Then any program that uses that field/function will get semantic errors.")))),(0,i.kt)("h2",{id:"updating-a-contract"},"Updating a Contract"),(0,i.kt)("p",null,"Changes to contracts can be introduced by adding new contracts, removing existing contracts, or updating existing\ncontracts. However, some of these changes may lead to data inconsistencies as stated above."),(0,i.kt)("h4",{id:"valid-changes"},"Valid Changes"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Adding a new contract is valid."),(0,i.kt)("li",{parentName:"ul"},"Removing a contract/contract-interface that doesn't have enum declarations is valid."),(0,i.kt)("li",{parentName:"ul"},"Updating a contract is valid, under the restrictions described in the below sections.")),(0,i.kt)("h4",{id:"invalid-changes"},"Invalid Changes"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Removing a contract/contract-interface that contains enum declarations is not valid.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Removing a contract allows adding a new contract with the same name."),(0,i.kt)("li",{parentName:"ul"},"The new contract could potentially have enum declarations with the same names as in the old contract, but with\ndifferent structures."),(0,i.kt)("li",{parentName:"ul"},"This could change the meaning of the already stored values of those enum types.")))),(0,i.kt)("p",null,"A contract may consist of fields and other declarations such as composite types, functions, constructors, etc.\nWhen an existing contract is updated, all its inner declarations are also validated."),(0,i.kt)("h3",{id:"contract-fields"},"Contract Fields"),(0,i.kt)("p",null,"When a contract is deployed, the fields of the contract are stored in an account's contract storage.\nChanging the fields of a contract only changes the way the program treats the data, but does not change the already\nstored data itself, which could potentially result in runtime inconsistencies as mentioned in the previous section."),(0,i.kt)("p",null,"See the ",(0,i.kt)("a",{parentName:"p",href:"#fields"},"section about fields below")," for the possible updates that can be done to the fields, and the restrictions\nimposed on changing fields of a contract."),(0,i.kt)("h3",{id:"nested-declarations"},"Nested Declarations"),(0,i.kt)("p",null,"Contracts can have nested composite type declarations such as structs, resources, interfaces, and enums.\nWhen a contract is updated, its nested declarations are checked, because:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"They can be used as type annotation for the fields of the same contract, directly or indirectly."),(0,i.kt)("li",{parentName:"ul"},"Any third-party contract can import the types defined in this contract and use them as type annotations."),(0,i.kt)("li",{parentName:"ul"},"Hence, changing the type definition is the same as changing the type annotation of such a field (which is also invalid,\nas described in the ",(0,i.kt)("a",{parentName:"li",href:"#fields"},"section about fields fields")," below).")),(0,i.kt)("p",null,"Changes that can be done to the nested declarations, and the update restrictions are described in following sections:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#structs-resources-and-interfaces"},"Structs, resources and interface")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#enums"},"Enums")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#functions"},"Functions")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#constructors"},"Constructors"))),(0,i.kt)("h2",{id:"fields"},"Fields"),(0,i.kt)("p",null,"A field may belong to a contract, struct, resource, or interface."),(0,i.kt)("h4",{id:"valid-changes-1"},"Valid Changes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Removing a field is valid"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cadence"},"// Existing contract\n\npub contract Foo {\n    pub var a: String\n    pub var b: Int\n}\n")))),(0,i.kt)("p",null,"  // Updated contract"),(0,i.kt)("p",null,"  pub contract Foo {\npub var a: String\n}"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"- It leaves data for the removed field unused at the storage, as it is no longer accessible.\n- However, it does not cause any runtime crashes.\n\n- Changing the order of fields is valid.\n```cadence\n// Existing contract\n\npub contract Foo {\n    pub var a: String\n    pub var b: Int\n}\n\n\n// Updated contract\n\npub contract Foo {\n    pub var b: Int\n    pub var a: String\n}\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Changing the access modifier of a field is valid."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cadence"},"// Existing contract\n\npub contract Foo {\n    pub var a: String\n}\n")))),(0,i.kt)("p",null,"  // Updated contract"),(0,i.kt)("p",null,"  pub contract Foo {\npriv var a: String   // access modifier changed to 'priv'\n}"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"\n#### Invalid Changes\n- Adding a new field is not valid.\n```cadence\n// Existing contract\n\npub contract Foo {\n    pub var a: String\n}\n\n\n// Updated contract\n\npub contract Foo {\n    pub var a: String\n    pub var b: Int      // Invalid new field\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"- Initializer of a contract only run once, when the contract is deployed for the first time. It does not rerun\n  when the contract is updated. However it is still required to be present in the updated contract to satisfy type checks.\n- Thus, the stored data won't have the new field, as the initializations for the newly added fields do not get\n  executed.\n- Decoding stored data will result in garbage or missing values for such fields.\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Changing the type of existing field is not valid."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cadence"},"// Existing contract\n\npub contract Foo {\n    pub var a: String\n}\n")))),(0,i.kt)("p",null,"  // Updated contract"),(0,i.kt)("p",null,"  pub contract Foo {\npub var a: Int      // Invalid type change\n}"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"  - In an already stored contract, the field `a` would have a value of type `String`.\n  - Changing the type of the field `a` to `Int`, would make the runtime read the already stored `String`\n    value as an `Int`, which will result in deserialization errors.\n  - Changing the field type to a subtype/supertype of the existing type is also not valid, as it would also\n    potentially cause issues while decoding/encoding.\n    - e.g: Changing an `Int64` field to `Int8` - Stored field could have a numeric value`624`, which exceeds the value space\n      for `Int8`.\n    - However, this is a limitation in the current implementation, and the future versions of Cadence may support\n      changing the type of field to a subtype, by providing means to migrate existing fields.\n\n## Structs, Resources and Interfaces\n\n#### Valid Changes:\n- Adding a new struct, resource, or interface is valid.\n- Adding an interface conformance to a struct/resource is valid, since the stored data only\nstores concrete type/value, but doesn't store the conformance info.\n```cadence\n// Existing struct\n\npub struct Foo {\n}\n\n\n// Upated struct\n\npub struct Foo: T {\n}\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"However, if adding a conformance also requires changing the existing structure (e.g: adding a new field that is\nenforced by the new conformance), then the other restrictions (such as ",(0,i.kt)("a",{parentName:"li",href:"#fields"},"restrictions on fields"),") may\nprevent performing such an update.")),(0,i.kt)("h4",{id:"invalid-changes-1"},"Invalid Changes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Removing an existing declaration is not valid."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Removing a declaration allows adding a new declaration with the same name, but with a different structure."),(0,i.kt)("li",{parentName:"ul"},"Any program that uses that declaration would face inconsistencies in the stored data."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Renaming a declaration is not valid. It can have the same effect as removing an existing declaration and adding\na new one.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Changing the type of declaration is not valid. i.e: Changing from a struct to interface, and vise versa."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cadence"},"// Existing struct\n\npub struct Foo {\n}\n")))),(0,i.kt)("p",null,"  // Changed to a struct interface"),(0,i.kt)("p",null,"  pub struct interface Foo {    // Invalid type declaration change\n}"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"- Removing an interface conformance of a struct/resource is not valid.\n```cadence\n// Existing struct\n\npub struct Foo: T {\n}\n\n\n// Upated struct\n\npub struct Foo {\n}\n")),(0,i.kt)("h3",{id:"updating-members"},"Updating Members"),(0,i.kt)("p",null,"Similar to contracts, these composite declarations: structs, resources, and interfaces also can have fields and\nother nested declarations as its member.\nUpdating such a composite declaration would also include updating all of its members."),(0,i.kt)("p",null,"Below sections describes the restrictions imposed on updating the members of a struct, resource or an interface."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#fields"},"Fields")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#structs-resources-and-interfaces"},"Nested structs, resources and interfaces")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#enums"},"Enums")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#functions"},"Functions")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#constructors"},"Constructors"))),(0,i.kt)("h2",{id:"enums"},"Enums"),(0,i.kt)("h4",{id:"valid-changes-2"},"Valid Changes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Adding a new enum declaration is valid.")),(0,i.kt)("h4",{id:"invalid-changes-2"},"Invalid Changes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Removing an existing enum declaration is invalid."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Otherwise, it is possible to remove an existing enum and add a new enum declaration with the same name,\nbut with a different structure."),(0,i.kt)("li",{parentName:"ul"},"The new structure could potentially have incompatible changes (such as changed types, changed enum-cases, etc)."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Changing the name is invalid, as it is equivalent to removing an existing enum and adding a new one.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Changing the raw type is invalid."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cadence"},"// Existing enum with `Int` raw type\n\npub enum Color: Int {\n  pub case RED\n  pub case BLUE\n}\n")))),(0,i.kt)("p",null,"  // Updated enum with ",(0,i.kt)("inlineCode",{parentName:"p"},"UInt8")," raw type"),(0,i.kt)("p",null,"  pub enum Color: UInt8 {    // Invalid change of raw type\npub case RED\npub case BLUE\n}"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"- When the enum value is stored, the raw value associated with the enum-case gets stored.\n- If the type is changed, then deserializing could fail if the already stored values are not in the same value space\n  as the updated type.\n\n### Updating Enum Cases\nEnums consist of enum-case declarations, and updating an enum may also include changing the enums cases as well.\nEnum cases are represented using their raw-value at the Cadence interpreter and runtime.\nHence, any change that causes an enum-case to change its raw value is not permitted.\nOtherwise, a changed raw-value could cause an already stored enum value to have a different meaning than what\nit originally was (type confusion).\n\n#### Valid Changes:\n- Adding an enum-case at the end of the existing enum-cases is valid.\n```cadence\n// Existing enum\n\npub enum Color: Int {\n  pub case RED\n  pub case BLUE\n}\n\n\n// Updated enum\n\npub enum Color: Int {\n  pub case RED\n  pub case BLUE\n  pub case GREEN    // valid new enum-case at the bottom\n}\n")),(0,i.kt)("h4",{id:"invalid-changes-3"},"Invalid Changes"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Adding an enum-case at the top or in the middle of the existing enum-cases is invalid."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cadence"},"// Existing enum\n\npub enum Color: Int {\n  pub case RED\n  pub case BLUE\n}\n")))),(0,i.kt)("p",null,"  // Updated enum"),(0,i.kt)("p",null,"  pub enum Color: Int {\npub case RED\npub case GREEN    // invalid new enum-case in the middle\npub case BLUE\n}"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"- Changing the name of an enum-case is invalid.\n```cadence\n// Existing enum\n\npub enum Color: Int {\n  pub case RED\n  pub case BLUE\n}\n\n\n// Updated enum\n\npub enum Color: Int {\n  pub case RED\n  pub case GREEN    // invalid change of names\n}\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Previously stored raw values for ",(0,i.kt)("inlineCode",{parentName:"p"},"Color.BLUE")," now represents ",(0,i.kt)("inlineCode",{parentName:"p"},"Color.GREEN"),". i.e: The stored values have changed\ntheir meaning, and hence not a valid change.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Similarly, it is possible to add a new enum with the old name ",(0,i.kt)("inlineCode",{parentName:"p"},"BLUE"),", which gets a new raw value. Then the same\nenum-case ",(0,i.kt)("inlineCode",{parentName:"p"},"Color.BLUE")," may have used two raw-values at runtime, before and after the change, which is also invalid.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Removing the enum case is invalid. Removing allows one to add and remove an enum-case which has the same effect\nas renaming."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cadence"},"// Existing enum\n\npub enum Color: Int {\n  pub case RED\n  pub case BLUE\n}\n")))),(0,i.kt)("p",null,"  // Updated enum"),(0,i.kt)("p",null,"  pub enum Color: Int {\npub case RED"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// invalid removal of `case BLUE`\n")),(0,i.kt)("p",null,"  }"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"- Changing the order of enum-cases is not permitted\n```cadence\n// Existing enum\n\npub enum Color: Int {\n  pub case RED\n  pub case BLUE\n}\n\n\n// Updated enum\n\npub enum Color: UInt8 {\n  pub case BLUE   // invalid change of order\n  pub case RED\n}\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Raw value of an enum is implicit, and corresponds to the defined order."),(0,i.kt)("li",{parentName:"ul"},"Changing the order of enum-cases has the same effect as changing the raw-value, which could cause storage\ninconsistencies and type-confusions as described earlier.")),(0,i.kt)("h2",{id:"functions"},"Functions"),(0,i.kt)("p",null,"Adding, changing, and deleting a function definition is always valid, as function definitions are never stored as data\n(function definitions are part of the code, but not data)."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Adding a function is valid."),(0,i.kt)("li",{parentName:"ul"},"Deleting a function is valid."),(0,i.kt)("li",{parentName:"ul"},"Changing a function signature (parameters, return types) is valid."),(0,i.kt)("li",{parentName:"ul"},"Changing a function body is valid."),(0,i.kt)("li",{parentName:"ul"},"Changing the access modifiers is valid.")),(0,i.kt)("p",null,"However, changing a ",(0,i.kt)("em",{parentName:"p"},"function type")," may or may not be valid, depending on where it is used:\nIf a function type is used in the type annotation of a composite type field (direct or indirect),\nthen changing the function type signature is the same as changing the type annotation of that field (which is invalid)."),(0,i.kt)("h2",{id:"constructors"},"Constructors"),(0,i.kt)("p",null,"Similar to functions, constructors are also not stored. Hence, any changes to constructors are valid."),(0,i.kt)("h2",{id:"imports"},"Imports"),(0,i.kt)("p",null,"A contract may import declarations (types, functions, variables, etc.) from other programs. These imported programs are\nalready validated at the time of their deployment. Hence, there is no need for validating any declaration every time\nthey are imported."))}p.isMDXComponent=!0}}]);