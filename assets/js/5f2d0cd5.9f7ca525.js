"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[467],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>m});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(t),h=r,m=d["".concat(l,".").concat(h)]||d[h]||p[h]||o;return t?a.createElement(m,i(i({ref:n},u),{},{components:t})):a.createElement(m,i({ref:n},u))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=h;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[d]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},51474:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=t(87462),r=(t(67294),t(3905));const o={title:"Functions"},i=void 0,s={unversionedId:"cadence/language/functions",id:"cadence/language/functions",title:"Functions",description:"Functions are sequences of statements that perform a specific task.",source:"@site/docs/cadence/language/functions.mdx",sourceDirName:"cadence/language",slug:"/cadence/language/functions",permalink:"/docs/cadence/language/functions",draft:!1,tags:[],version:"current",lastUpdatedBy:"Tom Haile",lastUpdatedAt:1682709940,formattedLastUpdatedAt:"Apr 28, 2023",frontMatter:{title:"Functions"},sidebar:"tutorialSidebar",previous:{title:"Events",permalink:"/docs/cadence/language/events"},next:{title:"glossary",permalink:"/docs/cadence/language/glossary"}},l={},c=[{value:"Function Declarations",id:"function-declarations",level:2},{value:"Function Expressions",id:"function-expressions",level:2},{value:"Function Calls",id:"function-calls",level:2},{value:"Function Types",id:"function-types",level:2},{value:"Closures",id:"closures",level:2},{value:"Argument Passing Behavior",id:"argument-passing-behavior",level:2},{value:"Function Preconditions and Postconditions",id:"function-preconditions-and-postconditions",level:2},{value:"Functions are Values",id:"functions-are-values",level:2}],u={toc:c},d="wrapper";function p(e){let{components:n,...t}=e;return(0,r.kt)(d,(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Functions are sequences of statements that perform a specific task.\nFunctions have parameters (inputs) and an optional return value (output).\nFunctions are typed: the function type consists of the parameter types and the return type."),(0,r.kt)("p",null,'Functions are values, i.e., they can be assigned to constants and variables,\nand can be passed as arguments to other functions.\nThis behavior is often called "first-class functions".'),(0,r.kt)("h2",{id:"function-declarations"},"Function Declarations"),(0,r.kt)("p",null,"Functions can be declared by using the ",(0,r.kt)("inlineCode",{parentName:"p"},"fun")," keyword, followed by the name of the declaration,\nthe parameters, the optional return type,\nand the code that should be executed when the function is called."),(0,r.kt)("p",null,"The parameters need to be enclosed in parentheses.\nThe return type, if any, is separated from the parameters by a colon (",(0,r.kt)("inlineCode",{parentName:"p"},":"),").\nThe function code needs to be enclosed in opening and closing braces."),(0,r.kt)("p",null,"Each parameter must have a name, which is the name that the argument value\nwill be available as within the function."),(0,r.kt)("p",null,"An additional argument label can be provided to require function calls to use the label\nto provide an argument value for the parameter."),(0,r.kt)("p",null,"Argument labels make code more explicit and readable.\nFor example, they avoid confusion about the order of arguments\nwhen there are multiple arguments that have the same type."),(0,r.kt)("p",null,"Argument labels should be named so they make sense from the perspective of the function call."),(0,r.kt)("p",null,"Argument labels precede the parameter name.\nThe special argument label ",(0,r.kt)("inlineCode",{parentName:"p"},"_")," indicates\nthat a function call can omit the argument label.\nIf no argument label is declared in the function declaration,\nthe parameter name is the argument label of the function declaration,\nand function calls must use the parameter name as the argument label."),(0,r.kt)("p",null,"Each parameter needs to have a type annotation,\nwhich follows the parameter name after a colon."),(0,r.kt)("p",null,"Function calls may provide arguments for parameters\nwhich are subtypes of the parameter types."),(0,r.kt)("p",null,"There is ",(0,r.kt)("strong",{parentName:"p"},"no")," support for optional parameters,\ni.e. default values for parameters,\nand variadic functions,\ni.e. functions that take an arbitrary amount of arguments."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a function named `double`, which multiples a number by two.\n//\n// The special argument label _ is specified for the parameter,\n// so no argument label has to be provided in a function call.\n//\nfun double(_ x: Int): Int {\n    return x * 2\n}\n\n// Call the function named `double` with the value 4 for the first parameter.\n//\n// The argument label can be omitted in the function call as the declaration\n// specifies the special argument label _ for the parameter.\n//\ndouble(2)  // is `4`\n")),(0,r.kt)("p",null,"It is possible to require argument labels for some parameters,\nand not require argument labels for other parameters."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a function named `clamp`. The function takes an integer value,\n// the lower limit, and the upper limit. It returns an integer between\n// the lower and upper limit.\n//\n// For the first parameter the special argument label _ is used,\n// so no argument label has to be given for it in a function call.\n//\n// For the second and third parameter no argument label is given,\n// so the parameter names are the argument labels, i.e., the parameter names\n// have to be given as argument labels in a function call.\n//\nfun clamp(_ value: Int, min: Int, max: Int): Int {\n    if value > max {\n        return max\n    }\n\n    if value < min {\n        return min\n    }\n\n    return value\n}\n\n// Declare a constant which has the result of a call to the function\n// named `clamp` as its initial value.\n//\n// For the first argument no label is given, as it is not required by\n// the function declaration (the special argument label `_` is specified).\n//\n// For the second and this argument the labels must be provided,\n// as the function declaration does not specify the special argument label `_`\n// for these two parameters.\n//\n// As the function declaration also does not specify argument labels\n// for these parameters, the parameter names must be used as argument labels.\n//\nlet clamped = clamp(123, min: 0, max: 100)\n// `clamped` is `100`\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a function named `send`, which transfers an amount\n// from one account to another.\n//\n// The implementation is omitted for brevity.\n//\n// The first two parameters of the function have the same type, so there is\n// a potential that a function call accidentally provides arguments in\n// the wrong order.\n//\n// While the parameter names `senderAddress` and `receiverAddress`\n// are descriptive inside the function, they might be too verbose\n// to require them as argument labels in function calls.\n//\n// For this reason the shorter argument labels `from` and `to` are specified,\n// which still convey the meaning of the two parameters without being overly\n// verbose.\n//\n// The name of the third parameter, `amount`, is both meaningful inside\n// the function and also in a function call, so no argument label is given,\n// and the parameter name is required as the argument label in a function call.\n//\nfun send(from senderAddress: Address, to receivingAddress: Address, amount: Int) {\n    // The function code is omitted for brevity.\n    // ...\n}\n\n// Declare a constant which refers to the sending account's address.\n//\n// The initial value is omitted for brevity.\n//\nlet sender: Address = // ...\n\n// Declare a constant which refers to the receiving account's address.\n//\n// The initial value is omitted for brevity.\n//\nlet receiver: Address = // ...\n\n// Call the function named `send`.\n//\n// The function declaration requires argument labels for all parameters,\n// so they need to be provided in the function call.\n//\n// This avoids ambiguity. For example, in some languages (like C) it is\n// a convention to order the parameters so that the receiver occurs first,\n// followed by the sender. In other languages, it is common to have\n// the sender be the first parameter, followed by the receiver.\n//\n// Here, the order is clear \u2013 send an amount from an account to another account.\n//\nsend(from: sender, to: receiver, amount: 100)\n")),(0,r.kt)("p",null,"The order of the arguments in a function call must\nmatch the order of the parameters in the function declaration."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a function named `test`, which accepts two parameters, named `first` and `second`\n//\nfun test(first: Int, second: Int) {\n    // ...\n}\n\n// Invalid: the arguments are provided in the wrong order,\n// even though the argument labels are provided correctly.\n//\ntest(second: 1, first: 2)\n")),(0,r.kt)("p",null,"Functions can be nested,\ni.e., the code of a function may declare further functions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a function which multiplies a number by two, and adds one.\n//\nfun doubleAndAddOne(_ x: Int): Int {\n\n    // Declare a nested function which multiplies a number by two.\n    //\n    fun double(_ x: Int) {\n        return x * 2\n    }\n\n    return double(x) + 1\n}\n\ndoubleAndAddOne(2)  // is `5`\n")),(0,r.kt)("p",null,"Functions do not support overloading."),(0,r.kt)("h2",{id:"function-expressions"},"Function Expressions"),(0,r.kt)("p",null,"Functions can be also used as expressions.\nThe syntax is the same as for function declarations,\nexcept that function expressions have no name, i.e., they are anonymous."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a constant named `double`, which has a function as its value.\n//\n// The function multiplies a number by two when it is called.\n//\n// This function's type is `((Int): Int)`.\n//\nlet double =\n    fun (_ x: Int): Int {\n        return x * 2\n    }\n")),(0,r.kt)("h2",{id:"function-calls"},"Function Calls"),(0,r.kt)("p",null,"Functions can be called (invoked). Function calls\nneed to provide exactly as many argument values as the function has parameters."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"fun double(_ x: Int): Int {\n    return x * 2\n}\n\n// Valid: the correct amount of arguments is provided.\n//\ndouble(2)  // is `4`\n\n// Invalid: too many arguments are provided.\n//\ndouble(2, 3)\n\n// Invalid: too few arguments are provided.\n//\ndouble()\n")),(0,r.kt)("h2",{id:"function-types"},"Function Types"),(0,r.kt)("p",null,"Function types consist of the function's parameter types\nand the function's return type."),(0,r.kt)("p",null,"The parameter types need to be enclosed in parentheses,\nfollowed by a colon (",(0,r.kt)("inlineCode",{parentName:"p"},":"),"), and end with the return type.\nThe whole function type needs to be enclosed in parentheses."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a function named `add`, with the function type `((Int, Int): Int)`.\n//\nfun add(a: Int, b: Int): Int {\n    return a + b\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a constant named `add`, with the function type `((Int, Int): Int)`\n//\nlet add: ((Int, Int): Int) =\n    fun (a: Int, b: Int): Int {\n        return a + b\n    }\n")),(0,r.kt)("p",null,"If the function has no return type, it implicitly has the return type ",(0,r.kt)("inlineCode",{parentName:"p"},"Void"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a constant named `doNothing`, which is a function\n// that takes no parameters and returns nothing.\n//\nlet doNothing: ((): Void) =\n    fun () {}\n")),(0,r.kt)("p",null,"Parentheses also control precedence.\nFor example, a function type ",(0,r.kt)("inlineCode",{parentName:"p"},"((Int): ((): Int))")," is the type\nfor a function which accepts one argument with type ",(0,r.kt)("inlineCode",{parentName:"p"},"Int"),",\nand which returns another function,\nthat takes no arguments and returns an ",(0,r.kt)("inlineCode",{parentName:"p"},"Int"),"."),(0,r.kt)("p",null,"The type ",(0,r.kt)("inlineCode",{parentName:"p"},"[((Int): Int); 2]")," specifies an array type of two functions,\nwhich accept one integer and return one integer."),(0,r.kt)("p",null,"Argument labels are not part of the function type.\nThis has the advantage that functions with different argument labels,\npotentially written by different authors are compatible\nas long as the parameter types and the return type match.\nIt has the disadvantage that function calls to plain function values,\ncannot accept argument labels."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a function which takes one argument that has type `Int`.\n// The function has type `((Int): Void)`.\n//\nfun foo1(x: Int) {}\n\n// Call function `foo1`. This requires an argument label.\nfoo1(x: 1)\n\n// Declare another function which takes one argument that has type `Int`.\n// The function also has type `((Int): Void)`.\n//\nfun foo2(y: Int) {}\n\n// Call function `foo2`. This requires an argument label.\nfoo2(y: 2)\n\n// Declare a variable which has type `((Int): Void)` and use `foo1`\n// as its initial value.\n//\nvar someFoo: ((Int): Void) = foo1\n\n// Call the function assigned to variable `someFoo`.\n// This is valid as the function types match.\n// This does neither require nor allow argument labels.\n//\nsomeFoo(3)\n\n// Assign function `foo2` to variable `someFoo`.\n// This is valid as the function types match.\n//\nsomeFoo = foo2\n\n// Call the function assigned to variable `someFoo`.\n// This does neither require nor allow argument labels.\n//\nsomeFoo(4)\n")),(0,r.kt)("h2",{id:"closures"},"Closures"),(0,r.kt)("p",null,"A function may refer to variables and constants of its outer scopes\nin which it is defined.\nIt is called a closure, because\nit is closing over those variables and constants.\nA closure can read from the variables and constants\nand assign to the variables it refers to."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a function named `makeCounter` which returns a function that\n// each time when called, returns the next integer, starting at 1.\n//\nfun makeCounter(): ((): Int) {\n    var count = 0\n    return fun (): Int {\n        // NOTE: read from and assign to the non-local variable\n        // `count`, which is declared in the outer function.\n        //\n        count = count + 1\n        return count\n    }\n}\n\nlet test = makeCounter()\ntest()  // is `1`\ntest()  // is `2`\n")),(0,r.kt)("h2",{id:"argument-passing-behavior"},"Argument Passing Behavior"),(0,r.kt)("p",null,"When arguments are passed to a function, they are copied.\nTherefore, values that are passed into a function\nare unchanged in the caller's scope when the function returns.\nThis behavior is known as\n",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/w/index.php?title=Evaluation_strategy&oldid=896280571#Call_by_value"},"call-by-value"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a function that changes the first two elements\n// of an array of integers.\n//\nfun change(_ numbers: [Int]) {\n    // Change the elements of the passed in array.\n    // The changes are only local, as the array was copied.\n    //\n    numbers[0] = 1\n    numbers[1] = 2\n    // `numbers` is `[1, 2]`\n}\n\nlet numbers = [0, 1]\n\nchange(numbers)\n// `numbers` is still `[0, 1]`\n")),(0,r.kt)("p",null,"Parameters are constant, i.e., it is not allowed to assign to them."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"fun test(x: Int) {\n    // Invalid: cannot assign to a parameter (constant)\n    //\n    x = 2\n}\n")),(0,r.kt)("h2",{id:"function-preconditions-and-postconditions"},"Function Preconditions and Postconditions"),(0,r.kt)("p",null,"Functions may have preconditions and may have postconditions.\nPreconditions and postconditions can be used to restrict the inputs (values for parameters)\nand output (return value) of a function."),(0,r.kt)("p",null,"Preconditions must be true right before the execution of the function.\nPreconditions are part of the function and introduced by the ",(0,r.kt)("inlineCode",{parentName:"p"},"pre")," keyword,\nfollowed by the condition block."),(0,r.kt)("p",null,"Postconditions must be true right after the execution of the function.\nPostconditions are part of the function and introduced by the ",(0,r.kt)("inlineCode",{parentName:"p"},"post")," keyword,\nfollowed by the condition block.\nPostconditions may only occur after preconditions, if any."),(0,r.kt)("p",null,"A conditions block consists of one or more conditions.\nConditions are expressions evaluating to a boolean."),(0,r.kt)("p",null,"Conditions may be written on separate lines,\nor multiple conditions can be written on the same line,\nseparated by a semicolon.\nThis syntax follows the syntax for ",(0,r.kt)("a",{parentName:"p",href:"syntax#semicolons"},"statements"),"."),(0,r.kt)("p",null,"Following each condition, an optional description can be provided after a colon.\nThe condition description is used as an error message when the condition fails."),(0,r.kt)("p",null,"In postconditions, the special constant ",(0,r.kt)("inlineCode",{parentName:"p"},"result")," refers to the result of the function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},'fun factorial(_ n: Int): Int {\n    pre {\n        // Require the parameter `n` to be greater than or equal to zero.\n        //\n        n >= 0:\n            "factorial is only defined for integers greater than or equal to zero"\n    }\n    post {\n        // Ensure the result will be greater than or equal to 1.\n        //\n        result >= 1:\n            "the result must be greater than or equal to 1"\n    }\n\n    if n < 1 {\n       return 1\n    }\n\n    return n * factorial(n - 1)\n}\n\nfactorial(5)  // is `120`\n\n// Run-time error: The given argument does not satisfy\n// the precondition `n >= 0` of the function, the program aborts.\n//\nfactorial(-2)\n')),(0,r.kt)("p",null,"In postconditions, the special function ",(0,r.kt)("inlineCode",{parentName:"p"},"before")," can be used\nto get the value of an expression just before the function is called."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},'var n = 0\n\nfun incrementN() {\n    post {\n        // Require the new value of `n` to be the old value of `n`, plus one.\n        //\n        n == before(n) + 1:\n            "n must be incremented by 1"\n    }\n\n    n = n + 1\n}\n')),(0,r.kt)("h2",{id:"functions-are-values"},"Functions are Values"),(0,r.kt)("p",null,'Functions are values ("first-class"), so they may be assigned to variables and fields\nor passed to functions as arguments.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a function named `transform` which applies a function to each element\n// of an array of integers and returns a new array of the results.\n//\npub fun transform(function: ((Int): Int), integers: [Int]): [Int] {\n    var newIntegers: [Int] = []\n    for integer in integers {\n        newIntegers.append(function(integer))\n    }\n    return newIntegers\n}\n\npub fun double(_ integer: Int): Int {\n    return integer * 2\n}\n\nlet newIntegers = transform(function: double, integers: [1, 2, 3])\n// `newIntegers` is `[2, 4, 6]`\n")))}p.isMDXComponent=!0}}]);