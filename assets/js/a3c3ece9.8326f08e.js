"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[5248],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>h});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(t),m=r,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||i;return t?a.createElement(h,l(l({ref:n},c),{},{components:t})):a.createElement(h,l({ref:n},c))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,l=new Array(i);l[0]=m;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[d]="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=t[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},75614:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var a=t(87462),r=(t(67294),t(3905));const i={title:"Operators"},l=void 0,o={unversionedId:"cadence/language/operators",id:"cadence/language/operators",title:"Operators",description:"Operators are special symbols that perform a computation",source:"@site/docs/cadence/language/operators.md",sourceDirName:"cadence/language",slug:"/cadence/language/operators",permalink:"/cadence/language/operators",draft:!1,tags:[],version:"current",lastUpdatedBy:"Tom Haile",lastUpdatedAt:1682618171,formattedLastUpdatedAt:"Apr 27, 2023",frontMatter:{title:"Operators"},sidebar:"tutorialSidebar",previous:{title:"Interfaces",permalink:"/cadence/language/interfaces"},next:{title:"References",permalink:"/cadence/language/references"}},s={},p=[{value:"Assignment Operator (<code>=</code>)",id:"assignment-operator-",level:2},{value:"Force-assignment operator (<code>&lt;-!</code>)",id:"force-assignment-operator--",level:2},{value:"Swapping Operator (<code>&lt;-&gt;</code>)",id:"swapping-operator--",level:2},{value:"Arithmetic Operators",id:"arithmetic-operators",level:2},{value:"Arithmetics on number super-types",id:"arithmetics-on-number-super-types",level:3},{value:"Logical Operators",id:"logical-operators",level:2},{value:"Comparison Operators",id:"comparison-operators",level:2},{value:"Comparing number super-types",id:"comparing-number-super-types",level:3},{value:"Bitwise Operators",id:"bitwise-operators",level:2},{value:"Bitwise Shifting Operators",id:"bitwise-shifting-operators",level:3},{value:"Ternary Conditional Operator",id:"ternary-conditional-operator",level:2},{value:"Casting Operators",id:"casting-operators",level:2},{value:"Static Casting Operator (<code>as</code>)",id:"static-casting-operator-as",level:3},{value:"Conditional Downcasting Operator (<code>as?</code>)",id:"conditional-downcasting-operator-as",level:3},{value:"Force-downcasting Operator (<code>as!</code>)",id:"force-downcasting-operator-as",level:3},{value:"Optional Operators",id:"optional-operators",level:2},{value:"Nil-Coalescing Operator (<code>??</code>)",id:"nil-coalescing-operator-",level:3},{value:"Force Unwrap Operator (<code>!</code>)",id:"force-unwrap-operator-",level:3},{value:"Precedence and Associativity",id:"precedence-and-associativity",level:2}],c={toc:p},d="wrapper";function u(e){let{components:n,...t}=e;return(0,r.kt)(d,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Operators are special symbols that perform a computation\nfor one or more values.\nThey are either unary, binary, or ternary."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Unary operators perform an operation for a single value.\nThe unary operator symbol appears before the value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Binary operators operate on two values.\nThe binary operator symbol appears between the two values (infix).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Ternary operators operate on three values.\nThe first operator symbol appears between the first and second value,\nthe second operator symbol appears between the second and third value (infix)."))),(0,r.kt)("h2",{id:"assignment-operator-"},"Assignment Operator (",(0,r.kt)("inlineCode",{parentName:"h2"},"="),")"),(0,r.kt)("p",null,"The binary assignment operator ",(0,r.kt)("inlineCode",{parentName:"p"},"=")," can be used\nto assign a new value to a variable.\nIt is only allowed in a statement and is not allowed in expressions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"var a = 1\na = 2\n// `a` is `2`\n\n\nvar b = 3\nvar c = 4\n\n// Invalid: The assignment operation cannot be used in an expression.\na = b = c\n\n// Instead, the intended assignment must be written in multiple statements.\nb = c\na = b\n")),(0,r.kt)("p",null,"Assignments to constants are invalid."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"let a = 1\n// Invalid: Assignments are only for variables, not constants.\na = 2\n")),(0,r.kt)("p",null,"The left-hand side of the assignment operand must be an identifier.\nFor arrays and dictionaries, this identifier can be followed\nby one or more index or access expressions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare an array of integers.\nlet numbers = [1, 2]\n\n// Change the first element of the array.\n//\nnumbers[0] = 3\n\n// `numbers` is `[3, 2]`\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare an array of arrays of integers.\nlet arrays = [[1, 2], [3, 4]]\n\n// Change the first element in the second array\n//\narrays[1][0] = 5\n\n// `arrays` is `[[1, 2], [5, 4]]`\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"let dictionaries = {\n  true: {1: 2},\n  false: {3: 4}\n}\n\ndictionaries[false][3] = 0\n\n// `dictionaries` is `{\n//   true: {1: 2},\n//   false: {3: 0}\n//}`\n")),(0,r.kt)("h2",{id:"force-assignment-operator--"},"Force-assignment operator (",(0,r.kt)("inlineCode",{parentName:"h2"},"<-!"),")"),(0,r.kt)("p",null,"The force-assignment operator (",(0,r.kt)("inlineCode",{parentName:"p"},"<-!"),") assigns a resource-typed value\nto an optional-typed variable if the variable is nil.\nIf the variable being assigned to is non-nil,\nthe execution of the program aborts."),(0,r.kt)("p",null,"The force-assignment operator is only used for ",(0,r.kt)("a",{parentName:"p",href:"resources"},"resource types"),"."),(0,r.kt)("h2",{id:"swapping-operator--"},"Swapping Operator (",(0,r.kt)("inlineCode",{parentName:"h2"},"<->"),")"),(0,r.kt)("p",null,"The binary swap operator ",(0,r.kt)("inlineCode",{parentName:"p"},"<->")," can be used\nto exchange the values of two variables.\nIt is only allowed in a statement and is not allowed in expressions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"var a = 1\nvar b = 2\na <-> b\n// `a` is `2`\n// `b` is `1`\n\nvar c = 3\n\n// Invalid: The swap operation cannot be used in an expression.\na <-> b <-> c\n\n// Instead, the intended swap must be written in multiple statements.\nb <-> c\na <-> b\n")),(0,r.kt)("p",null,"Both sides of the swap operation must be variable,\nassignment to constants is invalid."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"var a = 1\nlet b = 2\n\n// Invalid: Swapping is only possible for variables, not constants.\na <-> b\n")),(0,r.kt)("p",null,"Both sides of the swap operation must be an identifier,\nfollowed by one or more index or access expressions."),(0,r.kt)("h2",{id:"arithmetic-operators"},"Arithmetic Operators"),(0,r.kt)("p",null,"The unary pefix operator  ",(0,r.kt)("inlineCode",{parentName:"p"},"-")," negates an integer:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"let a = 1\n-a  // is `-1`\n")),(0,r.kt)("p",null,"There are four binary arithmetic operators:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Addition: ",(0,r.kt)("inlineCode",{parentName:"li"},"+")),(0,r.kt)("li",{parentName:"ul"},"Subtraction: ",(0,r.kt)("inlineCode",{parentName:"li"},"-")),(0,r.kt)("li",{parentName:"ul"},"Multiplication: ",(0,r.kt)("inlineCode",{parentName:"li"},"*")),(0,r.kt)("li",{parentName:"ul"},"Division: ",(0,r.kt)("inlineCode",{parentName:"li"},"/")),(0,r.kt)("li",{parentName:"ul"},"Remainder: ",(0,r.kt)("inlineCode",{parentName:"li"},"%"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"let a = 1 + 2\n// `a` is `3`\n")),(0,r.kt)("p",null,"The arguments for the operators need to be of the same type.\nThe result is always the same type as the arguments."),(0,r.kt)("p",null,"The division and remainder operators abort the program when the divisor is zero."),(0,r.kt)("p",null,"Arithmetic operations on the signed integer types\n",(0,r.kt)("inlineCode",{parentName:"p"},"Int8"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Int16"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Int32"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Int64"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Int128"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Int256"),",\nand on the unsigned integer types\n",(0,r.kt)("inlineCode",{parentName:"p"},"UInt8"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"UInt16"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"UInt32"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"UInt64"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"UInt128"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"UInt256"),",\ndo not cause values to overflow or underflow."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"let a: UInt8 = 255\n\n// Run-time error: The result `256` does not fit in the range of `UInt8`,\n// thus a fatal overflow error is raised and the program aborts\n//\nlet b = a + 1\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"let a: Int8 = 100\nlet b: Int8 = 100\n\n// Run-time error: The result `10000` does not fit in the range of `Int8`,\n// thus a fatal overflow error is raised and the program aborts\n//\nlet c = a * b\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"let a: Int8 = -128\n\n// Run-time error: The result `128` does not fit in the range of `Int8`,\n// thus a fatal overflow error is raised and the program aborts\n//\nlet b = -a\n")),(0,r.kt)("p",null,"Arithmetic operations on the unsigned integer types\n",(0,r.kt)("inlineCode",{parentName:"p"},"Word8"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Word16"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Word32"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Word64"),"\nmay cause values to overflow or underflow."),(0,r.kt)("p",null,"For example, the maximum value of an unsigned 8-bit integer is 255 (binary 11111111).\nAdding 1 results in an overflow, truncation to 8 bits, and the value 0."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"//    11111111 = 255\n// +         1\n// = 100000000 = 0\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"let a: Word8 = 255\na + 1 // is `0`\n")),(0,r.kt)("p",null,"Similarly, for the minimum value 0,\nsubtracting 1 wraps around and results in the maximum value 255."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"//    00000000\n// -         1\n// =  11111111 = 255\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"let b: Word8 = 0\nb - 1  // is `255`\n")),(0,r.kt)("h3",{id:"arithmetics-on-number-super-types"},"Arithmetics on number super-types"),(0,r.kt)("p",null,"Arithmetic operators are not supported for number supertypes\n(",(0,r.kt)("inlineCode",{parentName:"p"},"Number"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"SignedNumber"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"FixedPoint"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"SignedFixedPoint"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Integer"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"SignedInteger"),"),\nas they may or may not succeed at run-time."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"let x: Integer = 3 as Int8\nlet y: Integer = 4 as Int8\n\nlet z: Integer = x + y    // Static error\n")),(0,r.kt)("p",null,"Values of these types need to be cast to the desired type before performing the arithmetic operation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"let z: Integer = (x as! Int8) + (y as! Int8)\n")),(0,r.kt)("h2",{id:"logical-operators"},"Logical Operators"),(0,r.kt)("p",null,"Logical operators work with the boolean values ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Logical NOT: ",(0,r.kt)("inlineCode",{parentName:"p"},"!a")),(0,r.kt)("p",{parentName:"li"},"This unary prefix operator logically negates a boolean:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"let a = true\n!a  // is `false`\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Logical AND: ",(0,r.kt)("inlineCode",{parentName:"p"},"a && b")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"true && true  // is `true`\n\ntrue && false  // is `false`\n\nfalse && true  // is `false`\n\nfalse && false  // is `false`\n")),(0,r.kt)("p",{parentName:"li"},"If the left-hand side is false, the right-hand side is not evaluated.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Logical OR: ",(0,r.kt)("inlineCode",{parentName:"p"},"a || b")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"true || true  // is `true`\n\ntrue || false  // is `true`\n\nfalse || true  // is `true`\n\nfalse || false // is `false`\n")),(0,r.kt)("p",{parentName:"li"},"If the left-hand side is true, the right-hand side is not evaluated."))),(0,r.kt)("h2",{id:"comparison-operators"},"Comparison Operators"),(0,r.kt)("p",null,"Comparison operators work with boolean and integer values."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Equality: ",(0,r.kt)("inlineCode",{parentName:"p"},"=="),", is supported for booleans, numbers, addresses, strings, characters, enums, paths, ",(0,r.kt)("inlineCode",{parentName:"p"},"Type")," values, references, and ",(0,r.kt)("inlineCode",{parentName:"p"},"Void")," values (",(0,r.kt)("inlineCode",{parentName:"p"},"()"),"). Variable-sized arrays, fixed-size arrays, dictionaries, and optionals also support equality tests if their inner types do."),(0,r.kt)("p",{parentName:"li"},"Both sides of the equality operator may be optional, even of different levels,\nso it is for example possible to compare a non-optional with a double-optional (",(0,r.kt)("inlineCode",{parentName:"p"},"??"),")."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"1 == 1  // is `true`\n\n1 == 2  // is `false`\n")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"true == true  // is `true`\n\ntrue == false  // is `false`\n")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"let x: Int? = 1\nx == nil  // is `false`\n")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"let x: Int = 1\nx == nil  // is `false`\n")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Comparisons of different levels of optionals are possible.\nlet x: Int? = 2\nlet y: Int?? = nil\nx == y  // is `false`\n")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Comparisons of different levels of optionals are possible.\nlet x: Int? = 2\nlet y: Int?? = 2\nx == y  // is `true`\n")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Equality tests of arrays are possible if their inner types are equatable.\nlet xs: [Int] = [1, 2, 3]\nlet ys: [Int] = [1, 2, 3]\nxs == ys // is `true`\n\nlet xss: [[Int]] = [xs, xs, xs]\nlet yss: [[Int]] = [ys, ys, ys]\nxss == yss // is `true`\n")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Equality also applies to fixed-size arrays. If their lengths differ, the result is a type error.\nlet xs: [Int; 2] = [1, 2]\nlet ys: [Int; 2] = [0 + 1, 1 + 1]\nxs == ys // is `true`\n")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},'// Equality tests of dictionaries are possible if the key and value types are equatable.\nlet d1 = {"abc": 1, "def": 2}\nlet d2 = {"abc": 1, "def": 2}\nd1 == d2 // is `true`\n\nlet d3 = {"abc": {1: {"a": 1000}, 2: {"b": 2000}}, "def": {4: {"c": 1000}, 5: {"d": 2000}}}\nlet d4 = {"abc": {1: {"a": 1000}, 2: {"b": 2000}}, "def": {4: {"c": 1000}, 5: {"d": 2000}}}\nd3 == d4 // is `true`\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Inequality: ",(0,r.kt)("inlineCode",{parentName:"p"},"!="),", is supported for booleans, numbers, addresses, strings, characters, enums, paths, ",(0,r.kt)("inlineCode",{parentName:"p"},"Type")," values, references, and ",(0,r.kt)("inlineCode",{parentName:"p"},"Void")," values (",(0,r.kt)("inlineCode",{parentName:"p"},"()"),").\nVariable-sized arrays, fixed-size arrays, dictionaries, and optionals also support inequality tests if their inner types do."),(0,r.kt)("p",{parentName:"li"},"Both sides of the inequality operator may be optional, even of different levels,\nso it is for example possible to compare a non-optional with a double-optional (",(0,r.kt)("inlineCode",{parentName:"p"},"??"),")."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"1 != 1  // is `false`\n\n1 != 2  // is `true`\n")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"true != true  // is `false`\n\ntrue != false  // is `true`\n")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"let x: Int? = 1\nx != nil  // is `true`\n")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"let x: Int = 1\nx != nil  // is `true`\n")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Comparisons of different levels of optionals are possible.\nlet x: Int? = 2\nlet y: Int?? = nil\nx != y  // is `true`\n")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Comparisons of different levels of optionals are possible.\nlet x: Int? = 2\nlet y: Int?? = 2\nx != y  // is `false`\n")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Inequality tests of arrays are possible if their inner types are equatable.\nlet xs: [Int] = [1, 2, 3]\nlet ys: [Int] = [4, 5, 6]\nxs != ys // is `true`\n")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Inequality also applies to fixed-size arrays. If their lengths differ, the result is a type error.\nlet xs: [Int; 2] = [1, 2]\nlet ys: [Int; 2] = [1, 2]\nxs != ys // is `false`\n")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},'// Inequality tests of dictionaries are possible if the key and value types are equatable.\nlet d1 = {"abc": 1, "def": 2}\nlet d2 = {"abc": 1, "def": 500}\nd1 != d2 // is `true`\n\nlet d3 = {"abc": {1: {"a": 1000}, 2: {"b": 2000}}, "def": {4: {"c": 1000}, 5: {"d": 2000}}}\nlet d4 = {"abc": {1: {"a": 1000}, 2: {"b": 2000}}, "def": {4: {"c": 1000}, 5: {"d": 2000}}}\nd3 != d4 // is `false`\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Less than: ",(0,r.kt)("inlineCode",{parentName:"p"},"<"),", for integers"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"1 < 1  // is `false`\n\n1 < 2  // is `true`\n\n2 < 1  // is `false`\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Less or equal than: ",(0,r.kt)("inlineCode",{parentName:"p"},"<="),", for integers"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"1 <= 1  // is `true`\n\n1 <= 2  // is `true`\n\n2 <= 1  // is `false`\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Greater than: ",(0,r.kt)("inlineCode",{parentName:"p"},">"),", for integers"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"1 > 1  // is `false`\n\n1 > 2  // is `false`\n\n2 > 1  // is `true`\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Greater or equal than: ",(0,r.kt)("inlineCode",{parentName:"p"},">="),", for integers"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"1 >= 1  // is `true`\n\n1 >= 2  // is `false`\n\n2 >= 1  // is `true`\n")))),(0,r.kt)("h3",{id:"comparing-number-super-types"},"Comparing number super-types"),(0,r.kt)("p",null,"Similar to arithmetic operators, comparison operators are also not supported for number supertypes\n(",(0,r.kt)("inlineCode",{parentName:"p"},"Number"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"SignedNumber")," ",(0,r.kt)("inlineCode",{parentName:"p"},"FixedPoint"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"SignedFixedPoint"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Integer"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"SignedInteger"),"),\nas they may or may not succeed at run-time."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"let x: Integer = 3 as Int8\nlet y: Integer = 4 as Int8\n\nlet z: Bool = x > y    // Static error\n")),(0,r.kt)("p",null,"Values of these types need to be cast to the desired type before performing the arithmetic operation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"let z: Bool = (x as! Int8) > (y as! Int8)\n")),(0,r.kt)("h2",{id:"bitwise-operators"},"Bitwise Operators"),(0,r.kt)("p",null,"Bitwise operators enable the manipulation of individual bits of unsigned and signed integers.\nThey're often used in low-level programming."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Bitwise AND: ",(0,r.kt)("inlineCode",{parentName:"p"},"a & b")),(0,r.kt)("p",{parentName:"li"},"Returns a new integer whose bits are 1 only if the bits were 1 in ",(0,r.kt)("em",{parentName:"p"},"both")," input integers:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"let firstFiveBits = 0b11111000\nlet lastFiveBits  = 0b00011111\nlet middleTwoBits = firstFiveBits & lastFiveBits  // is 0b00011000\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Bitwise OR: ",(0,r.kt)("inlineCode",{parentName:"p"},"a | b")),(0,r.kt)("p",{parentName:"li"},"Returns a new integer whose bits are 1 only if the bits were 1 in ",(0,r.kt)("em",{parentName:"p"},"either")," input integers:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"let someBits = 0b10110010\nlet moreBits = 0b01011110\nlet combinedbits = someBits | moreBits  // is 0b11111110\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Bitwise XOR: ",(0,r.kt)("inlineCode",{parentName:"p"},"a ^ b")),(0,r.kt)("p",{parentName:"li"},"Returns a new integer whose bits are 1 where the input bits are different,\nand are 0 where the input bits are the same:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"let firstBits = 0b00010100\nlet otherBits = 0b00000101\nlet outputBits = firstBits ^ otherBits  // is 0b00010001\n")))),(0,r.kt)("h3",{id:"bitwise-shifting-operators"},"Bitwise Shifting Operators"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Bitwise LEFT SHIFT: ",(0,r.kt)("inlineCode",{parentName:"p"},"a << b")),(0,r.kt)("p",{parentName:"li"},"Returns a new integer with all bits moved to the left by a certain number of places."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"let someBits = 4  // is 0b00000100\nlet shiftedBits = someBits << 2   // is 0b00010000\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Bitwise RIGHT SHIFT: ",(0,r.kt)("inlineCode",{parentName:"p"},"a >> b")),(0,r.kt)("p",{parentName:"li"},"Returns a new integer with all bits moved to the right by a certain number of places."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"let someBits = 8  // is 0b00001000\nlet shiftedBits = someBits >> 2   // is 0b00000010\n")))),(0,r.kt)("p",null,"For unsigned integers, the bitwise shifting operators perform ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Logical_shift"},"logical shifting"),",\nfor signed integers, they perform ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Arithmetic_shift"},"arithmetic shifting"),"."),(0,r.kt)("h2",{id:"ternary-conditional-operator"},"Ternary Conditional Operator"),(0,r.kt)("p",null,"There is only one ternary conditional operator, the ternary conditional operator (",(0,r.kt)("inlineCode",{parentName:"p"},"a ? b : c"),")."),(0,r.kt)("p",null,"It behaves like an if-statement, but is an expression:\nIf the first operator value is true, the second operator value is returned.\nIf the first operator value is false, the third value is returned."),(0,r.kt)("p",null,"The first value must be a boolean (must have the type ",(0,r.kt)("inlineCode",{parentName:"p"},"Bool"),").\nThe second value and third value can be of any type.\nThe result type is the least common supertype of the second and third value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"let x = 1 > 2 ? 3 : 4\n// `x` is `4` and has type `Int`\n\nlet y = 1 > 2 ? nil : 3\n// `y` is `3` and has type `Int?`\n")),(0,r.kt)("h2",{id:"casting-operators"},"Casting Operators"),(0,r.kt)("h3",{id:"static-casting-operator-as"},"Static Casting Operator (",(0,r.kt)("inlineCode",{parentName:"h3"},"as"),")"),(0,r.kt)("p",null,"The static casting operator ",(0,r.kt)("inlineCode",{parentName:"p"},"as")," can be used to statically type cast a value to a type."),(0,r.kt)("p",null,'If the static type of the value is a subtype of the given type (the "target" type),\nthe operator returns the value as the given type.'),(0,r.kt)("p",null,"The cast is performed statically, i.e. when the program is type-checked.\nOnly the static type of the value is considered, not the run-time type of the value."),(0,r.kt)("p",null,"This means it is not possible to downcast using this operator.\nConsider using the ",(0,r.kt)("a",{parentName:"p",href:"#conditional-downcasting-operator-as"},"conditional downcasting operator ",(0,r.kt)("inlineCode",{parentName:"a"},"as?"))," instead."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a constant named `integer` which has type `Int`.\n//\nlet integer: Int = 1\n\n// Statically cast the value of `integer` to the supertype `Number`.\n// The cast succeeds, because the type of the variable `integer`,\n// the type `Int`, is a subtype of type `Number`.\n// This is an upcast.\n//\nlet number = integer as Number\n// `number` is `1` and has type `Number`\n\n// Declare a constant named `something` which has type `AnyStruct`,\n// with an initial value which has type `Int`.\n//\nlet something: AnyStruct = 1\n\n// Statically cast the value of `something` to `Int`.\n// This is invalid, the cast fails, because the static type of the value is type `AnyStruct`,\n// which is not a subtype of type `Int`.\n//\nlet result = something as Int\n")),(0,r.kt)("h3",{id:"conditional-downcasting-operator-as"},"Conditional Downcasting Operator (",(0,r.kt)("inlineCode",{parentName:"h3"},"as?"),")"),(0,r.kt)("p",null,"The conditional downcasting operator ",(0,r.kt)("inlineCode",{parentName:"p"},"as?")," can be used to dynamically type cast a value to a type.\nThe operator returns an optional.\nIf the value has a run-time type that is a subtype of the target type\nthe operator returns the value as the target type,\notherwise the result is ",(0,r.kt)("inlineCode",{parentName:"p"},"nil"),"."),(0,r.kt)("p",null,"The cast is performed at run-time, i.e. when the program is executed,\nnot statically, i.e. when the program is checked."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a constant named `something` which has type `AnyStruct`,\n// with an initial value which has type `Int`.\n//\nlet something: AnyStruct = 1\n\n// Conditionally downcast the value of `something` to `Int`.\n// The cast succeeds, because the value has type `Int`.\n//\nlet number = something as? Int\n// `number` is `1` and has type `Int?`\n\n// Conditionally downcast the value of `something` to `Bool`.\n// The cast fails, because the value has type `Int`,\n// and `Bool` is not a subtype of `Int`.\n//\nlet boolean = something as? Bool\n// `boolean` is `nil` and has type `Bool?`\n")),(0,r.kt)("p",null,"Downcasting works for concrete types, but also works e.g. for nested types (e.g. arrays), interfaces, optionals, etc."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a constant named `values` which has type `[AnyStruct]`,\n// i.e. an array of arbitrarily typed values.\n//\nlet values: [AnyStruct] = [1, true]\n\nlet first = values[0] as? Int\n// `first` is `1` and has type `Int?`\n\nlet second = values[1] as? Bool\n// `second` is `true` and has type `Bool?`\n")),(0,r.kt)("h3",{id:"force-downcasting-operator-as"},"Force-downcasting Operator (",(0,r.kt)("inlineCode",{parentName:"h3"},"as!"),")"),(0,r.kt)("p",null,"The force-downcasting operator ",(0,r.kt)("inlineCode",{parentName:"p"},"as!")," behaves like the\n",(0,r.kt)("a",{parentName:"p",href:"#conditional-downcasting-operator-as"},"conditional downcasting operator ",(0,r.kt)("inlineCode",{parentName:"a"},"as?")),".\nHowever, if the cast succeeds, it returns a value of the given type instead of an optional,\nand if the cast fails, it aborts the program instead of returning ",(0,r.kt)("inlineCode",{parentName:"p"},"nil"),","),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a constant named `something` which has type `AnyStruct`,\n// with an initial value which has type `Int`.\n//\nlet something: AnyStruct = 1\n\n// Force-downcast the value of `something` to `Int`.\n// The cast succeeds, because the value has type `Int`.\n//\nlet number = something as! Int\n// `number` is `1` and has type `Int`\n\n// Force-downcast the value of `something` to `Bool`.\n// The cast fails, because the value has type `Int`,\n// and `Bool` is not a subtype of `Int`.\n//\nlet boolean = something as! Bool\n// Run-time error\n")),(0,r.kt)("h2",{id:"optional-operators"},"Optional Operators"),(0,r.kt)("h3",{id:"nil-coalescing-operator-"},"Nil-Coalescing Operator (",(0,r.kt)("inlineCode",{parentName:"h3"},"??"),")"),(0,r.kt)("p",null,"The nil-coalescing operator ",(0,r.kt)("inlineCode",{parentName:"p"},"??")," returns\nthe value inside an optional if it contains a value,\nor returns an alternative value if the optional has no value,\ni.e., the optional value is ",(0,r.kt)("inlineCode",{parentName:"p"},"nil"),"."),(0,r.kt)("p",null,"If the left-hand side is non-nil, the right-hand side is not evaluated."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a constant which has an optional integer type\n//\nlet a: Int? = nil\n\n// Declare a constant with a non-optional integer type,\n// which is initialized to `a` if it is non-nil, or 42 otherwise.\n//\nlet b: Int = a ?? 42\n// `b` is 42, as `a` is nil\n")),(0,r.kt)("p",null,"The nil-coalescing operator can only be applied\nto values which have an optional type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a constant with a non-optional integer type.\n//\nlet a = 1\n\n// Invalid: nil-coalescing operator is applied to a value which has a non-optional type\n// (a has the non-optional type `Int`).\n//\nlet b = a ?? 2\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Invalid: nil-coalescing operator is applied to a value which has a non-optional type\n// (the integer literal is of type `Int`).\n//\nlet c = 1 ?? 2\n")),(0,r.kt)("p",null,"The type of the right-hand side of the operator (the alternative value) must be a subtype\nof the type of left-hand side, i.e. the right-hand side of the operator must\nbe the non-optional or optional type matching the type of the left-hand side."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a constant with an optional integer type.\n//\nlet a: Int? = nil\nlet b: Int? = 1\nlet c = a ?? b\n// `c` is `1` and has type `Int?`\n\n// Invalid: nil-coalescing operator is applied to a value of type `Int?`,\n// but the alternative has type `Bool`.\n//\nlet d = a ?? false\n")),(0,r.kt)("h3",{id:"force-unwrap-operator-"},"Force Unwrap Operator (",(0,r.kt)("inlineCode",{parentName:"h3"},"!"),")"),(0,r.kt)("p",null,"The force-unwrap operator (",(0,r.kt)("inlineCode",{parentName:"p"},"!"),") returns\nthe value inside an optional if it contains a value,\nor panics and aborts the execution if the optional has no value,\ni.e., the optional value is ",(0,r.kt)("inlineCode",{parentName:"p"},"nil"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a constant which has an optional integer type\n//\nlet a: Int? = nil\n\n// Declare a constant with a non-optional integer type,\n// which is initialized to `a` if `a` is non-nil.\n// If `a` is nil, the program aborts.\n//\nlet b: Int = a!\n// The program aborts because `a` is nil.\n\n// Declare another optional integer constant\nlet c: Int? = 3\n\n// Declare a non-optional integer\n// which is initialized to `c` if `c` is non-nil.\n// If `c` is nil, the program aborts.\nlet d: Int = c!\n// `d` is initialized to 3 because c isn't nil.\n\n")),(0,r.kt)("p",null,"The force-unwrap operator can only be applied\nto values which have an optional type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a constant with a non-optional integer type.\n//\nlet a = 1\n\n// Invalid: force-unwrap operator is applied to a value which has a\n// non-optional type (`a` has the non-optional type `Int`).\n//\nlet b = a!\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cadence"},"// Invalid: The force-unwrap operator is applied\n// to a value which has a non-optional type\n// (the integer literal is of type `Int`).\n//\nlet c = 1!\n")),(0,r.kt)("h2",{id:"precedence-and-associativity"},"Precedence and Associativity"),(0,r.kt)("p",null,"Operators have the following precedences, highest to lowest:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Unary precedence: ",(0,r.kt)("inlineCode",{parentName:"li"},"-"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"!"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"<-")),(0,r.kt)("li",{parentName:"ul"},"Cast precedence: ",(0,r.kt)("inlineCode",{parentName:"li"},"as"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"as?"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"as!")),(0,r.kt)("li",{parentName:"ul"},"Multiplication precedence: ",(0,r.kt)("inlineCode",{parentName:"li"},"*"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"/"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"%")),(0,r.kt)("li",{parentName:"ul"},"Addition precedence: ",(0,r.kt)("inlineCode",{parentName:"li"},"+"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"-")),(0,r.kt)("li",{parentName:"ul"},"Bitwise shift precedence: ",(0,r.kt)("inlineCode",{parentName:"li"},"<<"),", ",(0,r.kt)("inlineCode",{parentName:"li"},">>")),(0,r.kt)("li",{parentName:"ul"},"Bitwise conjunction precedence: ",(0,r.kt)("inlineCode",{parentName:"li"},"&")),(0,r.kt)("li",{parentName:"ul"},"Bitwise exclusive disjunction precedence: ",(0,r.kt)("inlineCode",{parentName:"li"},"^")),(0,r.kt)("li",{parentName:"ul"},"Bitwise disjunction precedence: ",(0,r.kt)("inlineCode",{parentName:"li"},"|")),(0,r.kt)("li",{parentName:"ul"},"Nil-Coalescing precedence: ",(0,r.kt)("inlineCode",{parentName:"li"},"??")),(0,r.kt)("li",{parentName:"ul"},"Relational precedence: ",(0,r.kt)("inlineCode",{parentName:"li"},"<"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"<="),", ",(0,r.kt)("inlineCode",{parentName:"li"},">"),", ",(0,r.kt)("inlineCode",{parentName:"li"},">=")),(0,r.kt)("li",{parentName:"ul"},"Equality precedence: ",(0,r.kt)("inlineCode",{parentName:"li"},"=="),", ",(0,r.kt)("inlineCode",{parentName:"li"},"!=")),(0,r.kt)("li",{parentName:"ul"},"Logical conjunction precedence: ",(0,r.kt)("inlineCode",{parentName:"li"},"&&")),(0,r.kt)("li",{parentName:"ul"},"Logical disjunction precedence: ",(0,r.kt)("inlineCode",{parentName:"li"},"||")),(0,r.kt)("li",{parentName:"ul"},"Ternary precedence: ",(0,r.kt)("inlineCode",{parentName:"li"},"? :"))),(0,r.kt)("p",null,"All operators are left-associative, except for the following operators which are right-associative:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Ternary operator"),(0,r.kt)("li",{parentName:"ul"},"Nil-coalescing operator")),(0,r.kt)("p",null,"Expressions can be wrapped in parentheses to override precedence conventions,\ni.e. an alternate order should be indicated, or when the default order should be emphasized\ne.g. to avoid confusion.\nFor example, ",(0,r.kt)("inlineCode",{parentName:"p"},"(2 + 3) * 4")," forces addition to precede multiplication,\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"5 + (6 * 7)")," reinforces the default order."))}u.isMDXComponent=!0}}]);