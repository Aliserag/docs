"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[7829],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},u="mdxType",y={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),d=a,f=u["".concat(s,".").concat(d)]||u[d]||y[d]||i;return n?r.createElement(f,o(o({ref:t},p),{},{components:n})):r.createElement(f,o({ref:t},p))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:a,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},56569:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>y,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var r=n(87462),a=(n(67294),n(3905));const i={title:"Run-time Types"},o=void 0,l={unversionedId:"cadence/language/run-time-types",id:"cadence/language/run-time-types",title:"Run-time Types",description:"Types can be represented at run-time.",source:"@site/docs/cadence/language/run-time-types.md",sourceDirName:"cadence/language",slug:"/cadence/language/run-time-types",permalink:"/cadence/language/run-time-types",draft:!1,tags:[],version:"current",lastUpdatedBy:"Tom Haile",lastUpdatedAt:1682538265,formattedLastUpdatedAt:"Apr 26, 2023",frontMatter:{title:"Run-time Types"},sidebar:"tutorialSidebar",previous:{title:"Restricted Types",permalink:"/cadence/language/restricted-types"},next:{title:"Scope",permalink:"/cadence/language/scope"}},s={},c=[{value:"Getting the Type from a Value",id:"getting-the-type-from-a-value",level:3},{value:"Constructing a Run-time Type",id:"constructing-a-run-time-type",level:3},{value:"Asserting the Type of a Value",id:"asserting-the-type-of-a-value",level:3}],p={toc:c},u="wrapper";function y(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Types can be represented at run-time.\nTo create a type value, use the constructor function ",(0,a.kt)("inlineCode",{parentName:"p"},"Type<T>()"),", which accepts the static type as a type argument."),(0,a.kt)("p",null,"This is similar to e.g. ",(0,a.kt)("inlineCode",{parentName:"p"},"T.self")," in Swift, ",(0,a.kt)("inlineCode",{parentName:"p"},"T::class"),"/",(0,a.kt)("inlineCode",{parentName:"p"},"KClass<T>")," in Kotlin, and ",(0,a.kt)("inlineCode",{parentName:"p"},"T.class"),"/",(0,a.kt)("inlineCode",{parentName:"p"},"Class<T>")," in Java."),(0,a.kt)("p",null,"For example, to represent the type ",(0,a.kt)("inlineCode",{parentName:"p"},"Int")," at run-time:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cadence"},"let intType: Type = Type<Int>()\n")),(0,a.kt)("p",null,"This works for both built-in and user-defined types. For example, to get the type value for a resource:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cadence"},"resource Collectible {}\n\nlet collectibleType = Type<@Collectible>()\n\n// `collectibleType` has type `Type`\n")),(0,a.kt)("p",null,"Type values are comparable."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cadence"},"\nType<Int>() == Type<Int>()\n\nType<Int>() != Type<String>()\n")),(0,a.kt)("p",null,"The method ",(0,a.kt)("inlineCode",{parentName:"p"},"fun isSubtype(of: Type): Bool")," can be used to compare the run-time types of values."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cadence"},"Type<Int>().isSubtype(of: Type<Int>()) // true\n\nType<Int>().isSubtype(of: Type<String>()) // false\n\nType<Int>().isSubtype(of: Type<Int?>()) // true\n")),(0,a.kt)("p",null,"To get the run-time type's fully qualified type identifier, use the ",(0,a.kt)("inlineCode",{parentName:"p"},"let identifier: String")," field:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cadence"},'let type = Type<Int>()\ntype.identifier  // is "Int"\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cadence"},'// in account 0x1\n\nstruct Test {}\n\nlet type = Type<Test>()\ntype.identifier  // is "A.0000000000000001.Test"\n')),(0,a.kt)("h3",{id:"getting-the-type-from-a-value"},"Getting the Type from a Value"),(0,a.kt)("p",null,"The method ",(0,a.kt)("inlineCode",{parentName:"p"},"fun getType(): Type")," can be used to get the runtime type of a value."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cadence"},'let something = "hello"\n\nlet type: Type = something.getType()\n// `type` is `Type<String>()`\n')),(0,a.kt)("p",null,"This method returns the ",(0,a.kt)("strong",{parentName:"p"},"concrete run-time type")," of the object, ",(0,a.kt)("strong",{parentName:"p"},"not")," the static type."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a variable named `something` that has the *static* type `AnyResource`\n// and has a resource of type `Collectible`\n//\nlet something: @AnyResource <- create Collectible()\n\n// The resource's concrete run-time type is `Collectible`\n//\nlet type: Type = something.getType()\n// `type` is `Type<@Collectible>()`\n")),(0,a.kt)("h3",{id:"constructing-a-run-time-type"},"Constructing a Run-time Type"),(0,a.kt)("p",null,"Run-time types can also be constructed from type identifier strings using built-in constructor functions. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cadence"},"fun CompositeType(_ identifier: String): Type?\nfun InterfaceType(_ identifier: String): Type?\nfun RestrictedType(identifier: String?, restrictions: [String]): Type?\n")),(0,a.kt)("p",null,"Given a type identifier (as well as a list of identifiers for restricting interfaces\nin the case of ",(0,a.kt)("inlineCode",{parentName:"p"},"RestrictedType"),"), these functions will look up nominal types and\nproduce their run-time equivalents. If the provided identifiers do not correspond\nto any types, or (in the case of ",(0,a.kt)("inlineCode",{parentName:"p"},"RestrictedType"),") the provided combination of\nidentifiers would not type-check statically, these functions will produce ",(0,a.kt)("inlineCode",{parentName:"p"},"nil"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cadence"},'struct Test {}\nstruct interface I {}\nlet type: Type = CompositeType("A.0000000000000001.Test")\n// `type` is `Type<Test>`\n\nlet type2: Type = RestrictedType(\n    identifier: type.identifier, \n    restrictions: ["A.0000000000000001.I"]\n)\n// `type2` is `Type<Test{I}>`\n')),(0,a.kt)("p",null,"Other built-in functions will construct compound types from other run-types."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cadence"},"fun OptionalType(_ type: Type): Type\nfun VariableSizedArrayType(_ type: Type): Type\nfun ConstantSizedArrayType(type: Type, size: Int): Type\nfun FunctionType(parameters: [Type], return: Type): Type\n// returns `nil` if `key` is not valid dictionary key type\nfun DictionaryType(key: Type, value: Type): Type?\n// returns `nil` if `type` is not a reference type\nfun CapabilityType(_ type: Type): Type?\nfun ReferenceType(authorized: bool, type: Type): Type\n")),(0,a.kt)("h3",{id:"asserting-the-type-of-a-value"},"Asserting the Type of a Value"),(0,a.kt)("p",null,"The method ",(0,a.kt)("inlineCode",{parentName:"p"},"fun isInstance(_ type: Type): Bool")," can be used to check if a value has a certain type,\nusing the concrete run-time type, and considering subtyping rules,"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a variable named `collectible` that has the *static* type `Collectible`\n// and has a resource of type `Collectible`\n//\nlet collectible: @Collectible <- create Collectible()\n\n// The resource is an instance of type `Collectible`,\n// because the concrete run-time type is `Collectible`\n//\ncollectible.isInstance(Type<@Collectible>())  // is `true`\n\n// The resource is an instance of type `AnyResource`,\n// because the concrete run-time type `Collectible` is a subtype of `AnyResource`\n//\ncollectible.isInstance(Type<@AnyResource>())  // is `true`\n\n// The resource is *not* an instance of type `String`,\n// because the concrete run-time type `Collectible` is *not* a subtype of `String`\n//\ncollectible.isInstance(Type<String>())  // is `false`\n")),(0,a.kt)("p",null,"Note that the ",(0,a.kt)("strong",{parentName:"p"},"concrete run-time type")," of the object is used, ",(0,a.kt)("strong",{parentName:"p"},"not")," the static type."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a variable named `something` that has the *static* type `AnyResource`\n// and has a resource of type `Collectible`\n//\nlet something: @AnyResource <- create Collectible()\n\n// The resource is an instance of type `Collectible`,\n// because the concrete run-time type is `Collectible`\n//\nsomething.isInstance(Type<@Collectible>())  // is `true`\n\n// The resource is an instance of type `AnyResource`,\n// because the concrete run-time type `Collectible` is a subtype of `AnyResource`\n//\nsomething.isInstance(Type<@AnyResource>())  // is `true`\n\n// The resource is *not* an instance of type `String`,\n// because the concrete run-time type `Collectible` is *not* a subtype of `String`\n//\nsomething.isInstance(Type<String>())  // is `false`\n")),(0,a.kt)("p",null,"For example, this allows implementing a marketplace sale resource:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cadence"},'pub resource SimpleSale {\n\n    /// The resource for sale.\n    /// Once the resource is sold, the field becomes `nil`.\n    ///\n    pub var resourceForSale: @AnyResource?\n\n    /// The price that is wanted for the purchase of the resource.\n    ///\n    pub let priceForResource: UFix64\n\n    /// The type of currency that is required for the purchase.\n    ///\n    pub let requiredCurrency: Type\n    pub let paymentReceiver: Capability<&{FungibleToken.Receiver}>\n\n    /// `paymentReceiver` is the capability that will be borrowed\n    /// once a valid purchase is made.\n    /// It is expected to target a resource that allows depositing the paid amount\n    /// (a vault which has the type in `requiredCurrency`).\n    ///\n    init(\n        resourceForSale: @AnyResource,\n        priceForResource: UFix64,\n        requiredCurrency: Type,\n        paymentReceiver: Capability<&{FungibleToken.Receiver}>\n    ) {\n        self.resourceForSale <- resourceForSale\n        self.priceForResource = priceForResource\n        self.requiredCurrency = requiredCurrency\n        self.paymentReceiver = paymentReceiver\n    }\n\n    destroy() {\n        // When this sale resource is destroyed,\n        // also destroy the resource for sale.\n        // Another option could be to transfer it back to the seller.\n        destroy self.resourceForSale\n    }\n\n    /// buyObject allows purchasing the resource for sale by providing\n    /// the required funds.\n    /// If the purchase succeeds, the resource for sale is returned.\n    /// If the purchase fails, the program aborts.\n    ///\n    pub fun buyObject(with funds: @FungibleToken.Vault): @AnyResource {\n        pre {\n            // Ensure the resource is still up for sale\n            self.resourceForSale != nil: "The resource has already been sold"\n            // Ensure the paid funds have the right amount\n            funds.balance >= self.priceForResource: "Payment has insufficient amount"\n            // Ensure the paid currency is correct\n            funds.isInstance(self.requiredCurrency): "Incorrect payment currency"\n        }\n\n        // Transfer the paid funds to the payment receiver\n        // by borrowing the payment receiver capability of this sale resource\n        // and depositing the payment into it\n\n        let receiver = self.paymentReceiver.borrow()\n            ?? panic("failed to borrow payment receiver capability")\n\n        receiver.deposit(from: <-funds)\n        let resourceForSale <- self.resourceForSale <- nil\n        return <-resourceForSale\n    }\n}\n')))}y.isMDXComponent=!0}}]);