"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[750],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>g});var a=n(67294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var r=a.createContext({}),p=function(e){var t=a.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},s=function(e){var t=p(e.components);return a.createElement(r.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,i=e.originalType,r=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),u=p(n),m=l,g=u["".concat(r,".").concat(m)]||u[m]||d[m]||i;return n?a.createElement(g,o(o({ref:t},s),{},{components:n})):a.createElement(g,o({ref:t},s))}));function g(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=n.length,o=new Array(i);o[0]=m;var c={};for(var r in t)hasOwnProperty.call(t,r)&&(c[r]=t[r]);c.originalType=e,c[u]="string"==typeof e?e:l,o[1]=c;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},88317:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>c,toc:()=>p});var a=n(87462),l=(n(67294),n(3905));const i={},o="NFT Catalog",c={unversionedId:"tools/nft-catalog/overview",id:"tools/nft-catalog/overview",title:"NFT Catalog",description:"The NFT Catalog is an on chain registry listing NFT collections that exists on Flow which adhere to the NFT metadata standard. This empowers dApp developers to easily build on top of and discover interoperable NFT collections on Flow.",source:"@site/docs/tools/nft-catalog/overview.mdx",sourceDirName:"tools/nft-catalog",slug:"/tools/nft-catalog/overview",permalink:"/tools/nft-catalog/overview",draft:!1,tags:[],version:"current",lastUpdatedBy:"Tom Haile",lastUpdatedAt:1682540899,formattedLastUpdatedAt:"Apr 26, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"NPM Module",permalink:"/tools/nft-catalog/npm"},next:{title:"Flow SDK for Unity",permalink:"/tools/unity-sdk/"}},r={},p=[{value:"Live Site",id:"live-site",level:2},{value:"Contract Addresses",id:"contract-addresses",level:2},{value:"Submitting a Collection to the NFT Catalog",id:"submitting-a-collection-to-the-nft-catalog",level:2},{value:"Using the Catalog (For marketplaces and other NFT applications)",id:"using-the-catalog-for-marketplaces-and-other-nft-applications",level:2},{value:"Developer Usage",id:"developer-usage",level:2},{value:"1. Install the Flow CLI",id:"1-install-the-flow-cli",level:3},{value:"2. Install Node",id:"2-install-node",level:3},{value:"3. Clone the project",id:"3-clone-the-project",level:3},{value:"4. Install packages",id:"4-install-packages",level:3},{value:"5. Run Test Suite",id:"5-run-test-suite",level:3},{value:"License",id:"license",level:2}],s={toc:p},u="wrapper";function d(e){let{components:t,...n}=e;return(0,l.kt)(u,(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"nft-catalog"},"NFT Catalog"),(0,l.kt)("p",null,"The NFT Catalog is an on chain registry listing NFT collections that exists on Flow which adhere to the NFT metadata standard. This empowers dApp developers to easily build on top of and discover interoperable NFT collections on Flow."),(0,l.kt)("h2",{id:"live-site"},"Live Site"),(0,l.kt)("p",null,"Checkout the catalog ",(0,l.kt)("a",{parentName:"p",href:"https://www.flow-nft-catalog.com/"},"site")," to submit your NFT collection both on testnet and mainnet."),(0,l.kt)("h2",{id:"contract-addresses"},"Contract Addresses"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"NFTCatalog.cdc"),": This contract contains the NFT Catalog"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Network"),(0,l.kt)("th",{parentName:"tr",align:null},"Address"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Mainnet"),(0,l.kt)("td",{parentName:"tr",align:null},"0x49a7cda3a1eecc29")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Testnet"),(0,l.kt)("td",{parentName:"tr",align:null},"0x324c34e1c517e4db")))),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"NFTRetrieval.cdc"),": This contract contains helper functions to make it easier to discover NFTs within accounts and from the catalog"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Network"),(0,l.kt)("th",{parentName:"tr",align:null},"Address"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Mainnet"),(0,l.kt)("td",{parentName:"tr",align:null},"0x49a7cda3a1eecc29")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Testnet"),(0,l.kt)("td",{parentName:"tr",align:null},"0x324c34e1c517e4db")))),(0,l.kt)("h2",{id:"submitting-a-collection-to-the-nft-catalog"},"Submitting a Collection to the NFT Catalog"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Visit ",(0,l.kt)("a",{parentName:"p",href:"https://www.flow-nft-catalog.com/v"},"here"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Enter the address containing the NFT contract which contains the collection and select the contract."),(0,l.kt)("img",{width:"1509",alt:"Screen Shot 2023-02-08 at 9 40 01 AM",src:"https://user-images.githubusercontent.com/5430668/217561873-54beb50e-0ea2-46fb-b9f8-8dbe758ee12f.png"})),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Enter the storage path where the NFTs are stored and enter an address that holds a sample NFT or log in if you have access to an account that owns the NFT."),(0,l.kt)("img",{width:"1508",alt:"Screen Shot 2023-02-08 at 9 42 54 AM",src:"https://user-images.githubusercontent.com/5430668/217562366-e6cbf3cb-38b8-45cb-943e-e20185565743.png"})),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"The application will verify that your NFT collection implements the required Metadata views."),(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"The required metadata views include\u2026"),(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},"NFT Display",(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},"How to display an individual NFT part of the collection"))),(0,l.kt)("li",{parentName:"ol"},"External URL",(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},"A website for the NFT collection"))),(0,l.kt)("li",{parentName:"ol"},"Collection Data",(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},"Information needed to store and retrieve an NFT"))),(0,l.kt)("li",{parentName:"ol"},"Collection Display",(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},"How to display information about the NFT collection the NFT belongs to"))),(0,l.kt)("li",{parentName:"ol"},"Royalties",(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},"Any royalties that should be accounted for during marketplace transactions"))))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"You can find sample implementations of all these views in this example NFT ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/onflow/flow-nft/blob/master/contracts/ExampleNFT.cdc"},"contract"),".")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"If you are not implementing a view, the app will communicate this and you can update your NFT contract and try resubmitting."),(0,l.kt)("img",{width:"738",alt:"Screen Shot 2023-02-08 at 9 46 56 AM",src:"https://user-images.githubusercontent.com/5430668/217563435-86863297-183b-4345-9615-61f9d4212fe9.png"})))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Submit proposal transaction to the NFT catalog by entering a unique url safe identifier for the collection and a message including any additional context (like contact information)."),(0,l.kt)("img",{width:"1503",alt:"Screen Shot 2023-02-08 at 9 48 45 AM",src:"https://user-images.githubusercontent.com/5430668/217563785-65065f51-37bc-49c7-8b3e-ba5d1dda3b24.png"})),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Once submitted you can view all proposals ",(0,l.kt)("a",{parentName:"p",href:"https://www.flow-nft-catalog.com/proposals/mainnet"},"here")," to track the review of your NFT."))),(0,l.kt)("p",null,"If you would like to make a proposal manually, you may submit the following transaction with all parameters filled in: ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/dapperlabs/nft-catalog/blob/main/cadence/transactions/propose_nft_to_catalog.cdc"},"https://github.com/dapperlabs/nft-catalog/blob/main/cadence/transactions/propose_nft_to_catalog.cdc")),(0,l.kt)("p",null,"Proposals should be reviewed and approved within a few days. Reasons for a proposal being rejected may include:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Providing duplicate path or name information of an existing collection on the catalog"),(0,l.kt)("li",{parentName:"ul"},"Providing a not url safe or inaccurate name as the identifier")),(0,l.kt)("h2",{id:"using-the-catalog-for-marketplaces-and-other-nft-applications"},"Using the Catalog (For marketplaces and other NFT applications)"),(0,l.kt)("p",null,"All of the below examples use the catalog in mainnet, you may replace the imports to the testnet address when using the testnet network."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example 1 - Retrieve all NFT collections on the catalog")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-swift"},"import NFTCatalog from 0x49a7cda3a1eecc29\n\n/*\n    The catalog is returned as a `String: NFTCatalogMetadata`\n    The key string is intended to be a unique identifier for a specific collection.\n    The NFTCatalogMetadata contains collection-level views corresponding to each\n    collection identifier.\n*/\npub fun main(): {String : NFTCatalog.NFTCatalogMetadata} {\n    return NFTCatalog.getCatalog()\n\n}\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example 2 - Retrieve all collection names in the catalog")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-swift"},"import NFTCatalog from 0x49a7cda3a1eecc29\n\npub fun main(): [String] {\n        let catalog: {String : NFTCatalog.NFTCatalogMetadata} = NFTCatalog.getCatalog()\n        let catalogNames: [String] = []\n        for collectionIdentifier in catalog.keys {\n            catalogNames.append(catalog[collectionIdentifier]!.collectionDisplay.name)\n    }\n    return catalogNames\n}\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example 3 - Retrieve NFT collections and counts owned by an account")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-swift"},'import MetadataViews from 0x1d7e57aa55817448\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport NFTRetrieval from 0x49a7cda3a1eecc29\n\npub fun main(ownerAddress: Address) : {String : Number} {\n    let catalog = NFTCatalog.getCatalog()\n    let account = getAuthAccount(ownerAddress)\n    let items : {String : Number} = {}\n\n    for key in catalog.keys {\n        let value = catalog[key]!\n        let tempPathStr = "catalog".concat(key)\n        let tempPublicPath = PublicPath(identifier: tempPathStr)!\n        account.link<&{MetadataViews.ResolverCollection}>(\n            tempPublicPath,\n            target: value.collectionData.storagePath\n        )\n        let collectionCap = account.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)\n        if !collectionCap.check() {\n            continue\n        }\n        let count = NFTRetrieval.getNFTCountFromCap(collectionIdentifier : key, collectionCap : collectionCap)\n        if count != 0 {\n            items[key] = count\n        }\n    }\n\n    return items\n}\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Sample Response...")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},'{\n    "schmoes_prelaunch_token": 1\n}\n')),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example 4 - Retrieve all NFTs including metadata owned by an account")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-swift"},'import MetadataViews from 0x1d7e57aa55817448\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport NFTRetrieval from 0x49a7cda3a1eecc29\n\npub struct NFT {\n    pub let id : UInt64\n    pub let name : String\n    pub let description : String\n    pub let thumbnail : String\n    pub let externalURL : String\n    pub let storagePath : StoragePath\n    pub let publicPath : PublicPath\n    pub let privatePath: PrivatePath\n    pub let publicLinkedType: Type\n    pub let privateLinkedType: Type\n    pub let collectionName : String\n    pub let collectionDescription: String\n    pub let collectionSquareImage : String\n    pub let collectionBannerImage : String\n    pub let royalties: [MetadataViews.Royalty]\n\n    init(\n            id: UInt64,\n            name : String,\n            description : String,\n            thumbnail : String,\n            externalURL : String,\n            storagePath : StoragePath,\n            publicPath : PublicPath,\n            privatePath : PrivatePath,\n            publicLinkedType : Type,\n            privateLinkedType : Type,\n                        collectionIdentifier: String,\n            collectionName : String,\n            collectionDescription : String,\n            collectionSquareImage : String,\n            collectionBannerImage : String,\n            royalties : [MetadataViews.Royalty]\n    ) {\n        self.id = id\n        self.name = name\n        self.description = description\n        self.thumbnail = thumbnail\n        self.externalURL = externalURL\n        self.storagePath = storagePath\n        self.publicPath = publicPath\n        self.privatePath = privatePath\n        self.publicLinkedType = publicLinkedType\n        self.privateLinkedType = privateLinkedType\n                self.collectionIdentifier = collectionIdentifier\n        self.collectionName = collectionName\n        self.collectionDescription = collectionDescription\n        self.collectionSquareImage = collectionSquareImage\n        self.collectionBannerImage = collectionBannerImage\n        self.royalties = royalties\n    }\n}\n\npub fun main(ownerAddress: Address) : { String : [NFT] } {\n    let catalog = NFTCatalog.getCatalog()\n    let account = getAuthAccount(ownerAddress)\n    let items : [NFTRetrieval.BaseNFTViewsV1] = []\n\n    let data : {String : [NFT] } = {}\n\n    for key in catalog.keys {\n        let value = catalog[key]!\n        let tempPathStr = "catalog".concat(key)\n        let tempPublicPath = PublicPath(identifier: tempPathStr)!\n        account.link<&{MetadataViews.ResolverCollection}>(\n            tempPublicPath,\n            target: value.collectionData.storagePath\n        )\n        let collectionCap = account.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)\n        if !collectionCap.check() {\n            continue\n        }\n        let views = NFTRetrieval.getNFTViewsFromCap(collectionIdentifier : key, collectionCap : collectionCap)\n\n        let items : [NFT] = []\n        for view in views {\n            let displayView = view.display\n            let externalURLView = view.externalURL\n            let collectionDataView = view.collectionData\n            let collectionDisplayView = view.collectionDisplay\n            let royaltyView = view.royalties\n            if (displayView == nil || externalURLView == nil || collectionDataView == nil || collectionDisplayView == nil || royaltyView == nil) {\n                // This NFT does not have the proper views implemented. Skipping....\n                continue\n            }\n\n            items.append(\n                NFT(\n                    id: view.id,\n                    name : displayView!.name,\n                    description : displayView!.description,\n                    thumbnail : displayView!.thumbnail.uri(),\n                    externalURL : externalURLView!.url,\n                    storagePath : collectionDataView!.storagePath,\n                    publicPath : collectionDataView!.publicPath,\n                    privatePath : collectionDataView!.providerPath,\n                    publicLinkedType : collectionDataView!.publicLinkedType,\n                    privateLinkedType : collectionDataView!.providerLinkedType,\n                                        collectionIdentifier: key,\n                    collectionName : collectionDisplayView!.name,\n                    collectionDescription : collectionDisplayView!.description,\n                    collectionSquareImage : collectionDisplayView!.squareImage.file.uri(),\n                    collectionBannerImage : collectionDisplayView!.bannerImage.file.uri(),\n                    royalties : royaltyView!.getRoyalties()\n                )\n            )\n        }\n        data[key] = items\n    }\n    return data\n}\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Sample Response...")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},'{\n    "FlovatarComponent": [],\n    "schmoes_prelaunch_token": [\n        s.aa16be98aac20e8073f923261531cbbdfae1464f570f5be796b57cdc97656248.NFT(\n            id: 1006,\n            name: "Schmoes Pre Launch Token #1006",\n            description: "",\n            thumbnail: "https://gateway.pinata.cloud/ipfs/QmXQ1iBke5wjcjYG22ACVXsCvtMJKEkwFiMf96UChP8uJq",\n            externalURL: "https://schmoes.io",\n            storagePath: /storage/SchmoesPreLaunchTokenCollection,\n            publicPath: /public/SchmoesPreLaunchTokenCollection,\n            privatePath: /private/SchmoesPreLaunchTokenCollection,\n            publicLinkedType: Type<&A.6c4fe48768523577.SchmoesPreLaunchToken.Collection{A.1d7e57aa55817448.NonFungibleToken.CollectionPublic,A.  1d7e57aa55817448.NonFungibleToken.Receiver,A.1d7e57aa55817448.MetadataViews.ResolverCollection}>(),\n            privateLinkedType: Type<&A.6c4fe48768523577.SchmoesPreLaunchToken.Collection{A.1d7e57aa55817448.NonFungibleToken.CollectionPublic,A.1d7e57aa55817448.NonFungibleToken.Provider,A.1d7e57aa55817448.MetadataViews.ResolverCollection}>(),\n            collectionName: "Schmoes Pre Launch Token",\n            collectionDescription: "",\n            collectionSquareImage: "https://gateway.pinata.cloud/ipfs/QmXQ1iBke5wjcjYG22ACVXsCvtMJKEkwFiMf96UChP8uJq",\n            collectionBannerImage: "https://gateway.pinata.cloud/ipfs/QmXQ1iBke5wjcjYG22ACVXsCvtMJKEkwFiMf96UChP8uJq",\n            royalties: []\n        )\n    ],\n    "Flovatar": []\n}\n')),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example 5 - Retrieve all NFTs including metadata owned by an account for large wallets")),(0,l.kt)("p",null,"For Wallets that have a lot of NFTs you may run into memory issues. The common pattern to get around this for now is to retrieve just the ID's in a wallet by calling the following script"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-swift"},'import MetadataViews from 0x1d7e57aa55817448\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport NFTRetrieval from 0x49a7cda3a1eecc29\n\npub fun main(ownerAddress: Address) : {String : [UInt64]} {\n    let catalog = NFTCatalog.getCatalog()\n    let account = getAuthAccount(ownerAddress)\n\n    let items : {String : [UInt64]} = {}\n\n    for key in catalog.keys {\n        let value = catalog[key]!\n        let tempPathStr = "catalogIDs".concat(key)\n        let tempPublicPath = PublicPath(identifier: tempPathStr)!\n        account.link<&{MetadataViews.ResolverCollection}>(\n            tempPublicPath,\n            target: value.collectionData.storagePath\n        )\n\n        let collectionCap = account.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)\n        if !collectionCap.check() {\n            continue\n        }\n\n        let ids = NFTRetrieval.getNFTIDsFromCap(collectionIdentifier : key, collectionCap : collectionCap)\n\n        if ids.length > 0 {\n            items[key] = ids\n        }\n    }\n    return items\n\n}\n')),(0,l.kt)("p",null,"and then use the ids to retrieve the full metadata for only those ids by calling the following script and passing in a map of collectlionIdentifer -> ","[ids]"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-swift"},'import MetadataViews from 0x1d7e57aa55817448\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport NFTRetrieval from 0x49a7cda3a1eecc29\n\npub struct NFT {\n    pub let id : UInt64\n    pub let name : String\n    pub let description : String\n    pub let thumbnail : String\n    pub let externalURL : String\n    pub let storagePath : StoragePath\n    pub let publicPath : PublicPath\n    pub let privatePath: PrivatePath\n    pub let publicLinkedType: Type\n    pub let privateLinkedType: Type\n    pub let collectionName : String\n    pub let collectionDescription: String\n    pub let collectionSquareImage : String\n    pub let collectionBannerImage : String\n    pub let royalties: [MetadataViews.Royalty]\n\n    init(\n            id: UInt64,\n            name : String,\n            description : String,\n            thumbnail : String,\n            externalURL : String,\n            storagePath : StoragePath,\n            publicPath : PublicPath,\n            privatePath : PrivatePath,\n            publicLinkedType : Type,\n            privateLinkedType : Type,\n            collectionName : String,\n            collectionDescription : String,\n            collectionSquareImage : String,\n            collectionBannerImage : String,\n            royalties : [MetadataViews.Royalty]\n    ) {\n        self.id = id\n        self.name = name\n        self.description = description\n        self.thumbnail = thumbnail\n        self.externalURL = externalURL\n        self.storagePath = storagePath\n        self.publicPath = publicPath\n        self.privatePath = privatePath\n        self.publicLinkedType = publicLinkedType\n        self.privateLinkedType = privateLinkedType\n        self.collectionName = collectionName\n        self.collectionDescription = collectionDescription\n        self.collectionSquareImage = collectionSquareImage\n        self.collectionBannerImage = collectionBannerImage\n        self.royalties = royalties\n    }\n}\n\npub fun main(ownerAddress: Address, collections: {String : [UInt64]}) : {String : [NFT] } {\n    let data : {String : [NFT] } = {}\n\n    let catalog = NFTCatalog.getCatalog()\n    let account = getAuthAccount(ownerAddress)\n    for collectionIdentifier in collections.keys {\n        if catalog.containsKey(collectionIdentifier) {\n            let value = catalog[collectionIdentifier]!\n            let tempPathStr = "catalog".concat(collectionIdentifier)\n            let tempPublicPath = PublicPath(identifier: tempPathStr)!\n            account.link<&{MetadataViews.ResolverCollection}>(\n                tempPublicPath,\n                target: value.collectionData.storagePath\n            )\n\n            let collectionCap = account.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)\n\n            if !collectionCap.check() {\n                return data\n            }\n\n            let views = NFTRetrieval.getNFTViewsFromIDs(collectionIdentifier : collectionIdentifier, ids: collections[collectionIdentifier]!, collectionCap : collectionCap)\n\n            let items : [NFT] = []\n\n            for view in views {\n                    let displayView = view.display\n                    let externalURLView = view.externalURL\n                    let collectionDataView = view.collectionData\n                    let collectionDisplayView = view.collectionDisplay\n                    let royaltyView = view.royalties\n                    if (displayView == nil || externalURLView == nil || collectionDataView == nil || collectionDisplayView == nil || royaltyView == nil) {\n                        // Bad NFT. Skipping....\n                        continue\n                    }\n\n                    items.append(\n                        NFT(\n                            id: view.id,\n                            name : displayView!.name,\n                            description : displayView!.description,\n                            thumbnail : displayView!.thumbnail.uri(),\n                            externalURL : externalURLView!.url,\n                            storagePath : collectionDataView!.storagePath,\n                            publicPath : collectionDataView!.publicPath,\n                            privatePath : collectionDataView!.providerPath,\n                            publicLinkedType : collectionDataView!.publicLinkedType,\n                            privateLinkedType : collectionDataView!.providerLinkedType,\n                            collectionName : collectionDisplayView!.name,\n                            collectionDescription : collectionDisplayView!.description,\n                            collectionSquareImage : collectionDisplayView!.squareImage.file.uri(),\n                            collectionBannerImage : collectionDisplayView!.bannerImage.file.uri(),\n                            royalties : royaltyView!.getRoyalties()\n                        )\n                    )\n                }\n\n                data[collectionIdentifier] = items\n        }\n    }\n\n\n    return data\n}\n')),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example 6 - Retrieve all MetadataViews for NFTs in a wallet")),(0,l.kt)("p",null,"If you're looking for some MetadataViews that aren't in the ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L36"},"core view list")," you can leverage this script to grab all the views each NFT supports. Note: You lose some typing here but get more data."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-swift"},'import MetadataViews from 0x1d7e57aa55817448\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport NFTRetrieval from 0x49a7cda3a1eecc29\n\npub struct NFTCollectionData {\n    pub let storagePath : StoragePath\n    pub let publicPath : PublicPath\n    pub let privatePath: PrivatePath\n    pub let publicLinkedType: Type\n    pub let privateLinkedType: Type\n\n    init(\n            storagePath : StoragePath,\n            publicPath : PublicPath,\n            privatePath : PrivatePath,\n            publicLinkedType : Type,\n            privateLinkedType : Type,\n    ) {\n        self.storagePath = storagePath\n        self.publicPath = publicPath\n        self.privatePath = privatePath\n        self.publicLinkedType = publicLinkedType\n        self.privateLinkedType = privateLinkedType\n    }\n}\n\npub fun main(ownerAddress: Address) : { String : {String : AnyStruct} }  {\n    let catalog = NFTCatalog.getCatalog()\n    let account = getAuthAccount(ownerAddress)\n    let items : [MetadataViews.NFTView] = []\n\n    let data : { String : {String : AnyStruct} } = {}\n\n    for key in catalog.keys {\n        let value = catalog[key]!\n        let tempPathStr = "catalog".concat(key)\n        let tempPublicPath = PublicPath(identifier: tempPathStr)!\n        account.link<&{MetadataViews.ResolverCollection}>(\n            tempPublicPath,\n            target: value.collectionData.storagePath\n        )\n        let collectionCap = account.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)\n        if !collectionCap.check() {\n            continue\n        }\n\n        var views = NFTRetrieval.getAllMetadataViewsFromCap(collectionIdentifier : key, collectionCap : collectionCap)\n\n        if views.keys.length == 0 {\n            continue\n        }\n\n        // Cadence doesn\'t support function return types, lets manually get rid of it\n        let nftCollectionDisplayView = views[Type<MetadataViews.NFTCollectionData>().identifier] as! MetadataViews.NFTCollectionData?\n        let collectionDataView = NFTCollectionData(\n                    storagePath : nftCollectionDisplayView!.storagePath,\n                    publicPath : nftCollectionDisplayView!.publicPath,\n                    privatePath : nftCollectionDisplayView!.providerPath,\n                    publicLinkedType : nftCollectionDisplayView!.publicLinkedType,\n                    privateLinkedType : nftCollectionDisplayView!.providerLinkedType,\n        )\n        views.insert(key: Type<MetadataViews.NFTCollectionData>().identifier, collectionDataView)\n\n        data[key] = views\n    }\n\n    return data\n}\n')),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example 7 - Setup a user\u2019s account to receive a specific collection")),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Run the following script to retrieve some collection-level information for an NFT collection identifier from the catalog")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-swift"},'import MetadataViews from 0x1d7e57aa55817448\nimport NFTCatalog from 0x49a7cda3a1eecc29\nimport NFTRetrieval from 0x49a7cda3a1eecc29\n\npub struct NFTCollection {\n    pub let storagePath : StoragePath\n    pub let publicPath : PublicPath\n    pub let privatePath: PrivatePath\n    pub let publicLinkedType: Type\n    pub let privateLinkedType: Type\n    pub let collectionName : String\n    pub let collectionDescription: String\n    pub let collectionSquareImage : String\n    pub let collectionBannerImage : String\n\n    init(\n            storagePath : StoragePath,\n            publicPath : PublicPath,\n            privatePath : PrivatePath,\n            publicLinkedType : Type,\n            privateLinkedType : Type,\n            collectionName : String,\n            collectionDescription : String,\n            collectionSquareImage : String,\n            collectionBannerImage : String\n    ) {\n        self.storagePath = storagePath\n        self.publicPath = publicPath\n        self.privatePath = privatePath\n        self.publicLinkedType = publicLinkedType\n        self.privateLinkedType = privateLinkedType\n        self.collectionName = collectionName\n        self.collectionDescription = collectionDescription\n        self.collectionSquareImage = collectionSquareImage\n        self.collectionBannerImage = collectionBannerImage\n    }\n}\n\npub fun main(collectionIdentifier : String) : NFT? {\n        let catalog = NFTCatalog.getCatalog()\n\n        assert(catalog.containsKey(collectionIdentifier), message: "Invalid Collection")\n\n              return NFTCollection(\n                  storagePath : collectionDataView!.storagePath,\n                  publicPath : collectionDataView!.publicPath,\n                  privatePath : collectionDataView!.providerPath,\n                  publicLinkedType : collectionDataView!.publicLinkedType,\n                  privateLinkedType : collectionDataView!.providerLinkedType,\n                  collectionName : collectionDisplayView!.name,\n                  collectionDescription : collectionDisplayView!.description,\n                  collectionSquareImage : collectionDisplayView!.squareImage.file.uri(),\n                  collectionBannerImage : collectionDisplayView!.bannerImage.file.uri()\n              )\n          }\n\n        panic("Invalid Token ID")\n}\n')),(0,l.kt)("ol",{start:2},(0,l.kt)("li",{parentName:"ol"},"This script result can then be used to form a transaction by inserting the relevant variables from above into a transaction template like the following:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-swift"},"import NonFungibleToken from 0x1d7e57aa55817448\nimport MetadataViews from 0x1d7e57aa55817448\n{ADDITIONAL_IMPORTS}\n\ntransaction {\n\n    prepare(signer: AuthAccount) {\n        // Create a new empty collection\n        let collection <- {CONTRACT_NAME}.createEmptyCollection()\n\n        // save it to the account\n        signer.save(<-collection, to: {STORAGE_PATH})\n\n        // create a public capability for the collection\n        signer.link<&{PUBLIC_LINKED_TYPE}>(\n            {PUBLIC_PATH},\n            target: {STORAGE_PATH}\n        )\n\n                // create a private capability for the collection\n        signer.link<&{PRIVATE_LINKED_TYPE}>(\n            {PRIVATE_PATH},\n            target: {STORAGE_PATH}\n        )\n    }\n}\n")),(0,l.kt)("h2",{id:"developer-usage"},"Developer Usage"),(0,l.kt)("h3",{id:"1-install-the-flow-cli"},"1. ",(0,l.kt)("a",{parentName:"h3",href:"https://github.com/onflow/flow-cli"},"Install the Flow CLI")),(0,l.kt)("h3",{id:"2-install-node"},"2. ",(0,l.kt)("a",{parentName:"h3",href:"https://nodejs.org/en/"},"Install Node")),(0,l.kt)("h3",{id:"3-clone-the-project"},"3. Clone the project"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sh"},"git clone --depth=1 https://github.com/onflow/nft-catalog.git\n")),(0,l.kt)("h3",{id:"4-install-packages"},"4. Install packages"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Run ",(0,l.kt)("inlineCode",{parentName:"li"},"npm install")," in the root of the project")),(0,l.kt)("h3",{id:"5-run-test-suite"},"5. Run Test Suite"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Run ",(0,l.kt)("inlineCode",{parentName:"li"},"npm test")," in the root of the project")),(0,l.kt)("h2",{id:"license"},"License"),(0,l.kt)("p",null,"The works in these files:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"cadence/contracts/FungibleToken.cdc"},"FungibleToken.cdc")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"cadence/contracts/NonFungibleToken.cdc"},"NonFungibleToken.cdc")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"cadence/contracts/ExampleNFT.cdc"},"ExampleNFT.cdc")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"cadence/contracts/MetadataViews.cdc"},"MetadataViews.cdc")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"cadence/contracts/NFTCatalog.cdc"},"NFTCatalog.cdc")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"cadence/contracts/NFTCatalogAdmin.cdc"},"NFTCatalogAdmin.cdc")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"cadence/contracts/NFTRetrieval.cdc"},"NFTRetrieval.cdc"))),(0,l.kt)("p",null,"are under the ",(0,l.kt)("a",{parentName:"p",href:"LICENSE"},"Unlicense"),"."))}d.isMDXComponent=!0}}]);