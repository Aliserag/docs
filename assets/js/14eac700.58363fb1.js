"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[7502],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>u});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var r=a.createContext({}),c=function(e){var t=a.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},h=function(e){var t=c(e.components);return a.createElement(r.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},w=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,s=e.originalType,r=e.parentName,h=l(e,["components","mdxType","originalType","parentName"]),p=c(n),w=o,u=p["".concat(r,".").concat(w)]||p[w]||d[w]||s;return n?a.createElement(u,i(i({ref:t},h),{},{components:n})):a.createElement(u,i({ref:t},h))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var s=n.length,i=new Array(s);i[0]=w;var l={};for(var r in t)hasOwnProperty.call(t,r)&&(l[r]=t[r]);l.originalType=e,l[p]="string"==typeof e?e:o,i[1]=l;for(var c=2;c<s;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}w.displayName="MDXCreateElement"},3406:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var a=n(87462),o=(n(67294),n(3905));const s={},i="Composability Chronicles #2: How to build a new experience on top of NFTs with Flowcase",l={unversionedId:"tools/nft-catalog/composability-flowcase-guide",id:"tools/nft-catalog/composability-flowcase-guide",title:"Composability Chronicles #2: How to build a new experience on top of NFTs with Flowcase",description:"2: How to build a new experience on top of NFTs with Flowcase",source:"@site/docs/tools/nft-catalog/composability-flowcase-guide.mdx",sourceDirName:"tools/nft-catalog",slug:"/tools/nft-catalog/composability-flowcase-guide",permalink:"/tools/nft-catalog/composability-flowcase-guide",draft:!1,tags:[],version:"current",lastUpdatedBy:"Tom Haile",lastUpdatedAt:1682540899,formattedLastUpdatedAt:"Apr 26, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Cadence Generation",permalink:"/tools/nft-catalog/cadence-generation"},next:{title:"NPM Module",permalink:"/tools/nft-catalog/npm"}},r={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Getting Started",id:"getting-started",level:2},{value:"Cadence Development",id:"cadence-development",level:2},{value:"Contract Creation",id:"contract-creation",level:3},{value:"Flowcase Transactions",id:"flowcase-transactions",level:3},{value:"Flowcase scripts",id:"flowcase-scripts",level:3},{value:"Flow Configuration",id:"flow-configuration",level:3},{value:"Front-End Development",id:"front-end-development",level:2},{value:"Creating a new showcase",id:"creating-a-new-showcase",level:3},{value:"View Showcases",id:"view-showcases",level:3},{value:"Removing a showcase",id:"removing-a-showcase",level:3},{value:"Conclusion",id:"conclusion",level:2}],h={toc:c},p="wrapper";function d(e){let{components:t,...n}=e;return(0,o.kt)(p,(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"composability-chronicles-2-how-to-build-a-new-experience-on-top-of-nfts-with-flowcase"},"Composability Chronicles #2: How to build a new experience on top of NFTs with Flowcase"),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"Composability is one of the key concepts behind the Flow blockchain. It allows developers to create new experiences by building on top of existing contracts and NFTs. With composability, developers can leverage the full power of the Flow network to create innovative and engaging experiences."),(0,o.kt)("p",null,"In this guide, we will walk through the process of building a composable app called ",(0,o.kt)("inlineCode",{parentName:"p"},"Flowcase"),". Flowcase will be will be an app that allows users to make showcases for any of their NFT collections on Flow, and store them on-chain for anyone to view. This is similar to NBATopShot showcases, with the added benefit that these showcases will let you select NFTs from any Flow collection, and all of the data of what you want to show will be available on-chain without any backend needed. This type of app which does not require hosting a backend of your own is sometimes referred to as a Serverless On-chain Distributed Applications (SODA), where we can take full advantage of Flow\u2019s capabilities along with the composability afforded to us by Flow\u2019s NFT design."),(0,o.kt)("p",null,"We will cover setting up the development environment, writing the contracts and building the front-end. By the end of this guide, you will have a solid understanding of how to build a composable app on Flow and what is required to make an application that can make use of NFTs that already exist on flow. This guide will assume that you have a beginner level understanding of cadence and a beginner level understanding of front-end development. It is suggested that you first go through the following guide on how to create a basic, composable NFT before going continuing with this guide, because a lot of the same concepts are used."),(0,o.kt)("p",null,"All of the resulting code from this guide is available ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/aishairzay/Flow-Serverless-React-Boilerplate/tree/flowcase"},"here"),"."),(0,o.kt)("h2",{id:"getting-started"},"Getting Started"),(0,o.kt)("p",null,"Before we begin building our composable app, we need to set up the development environment."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Download and install NodeJS (version 16.15.0) using the instructions ",(0,o.kt)("a",{parentName:"li",href:"https://nodejs.dev/en/download/"},"here"),"."),(0,o.kt)("li",{parentName:"ol"},"Download and install the Flow CLI, a command-line tool used to interact with the Flow blockchain. You can find the instructions for installing it ",(0,o.kt)("a",{parentName:"li",href:"https://developers.flow.com/tools/flow-cli/install"},"here"),"."),(0,o.kt)("li",{parentName:"ol"},"Using git, clone the ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/aishairzay/Flow-Serverless-React-Boilerplate"},"https://github.com/aishairzay/Flow-Serverless-React-Boilerplate")," repository as a starting point."),(0,o.kt)("li",{parentName:"ol"},"Navigate to the newly created ",(0,o.kt)("inlineCode",{parentName:"li"},"Flow-Serverless-React-Boilerplate")," folder with ",(0,o.kt)("inlineCode",{parentName:"li"},"cd Flow-Serverless-React-Boilerplate")," or open the folder with a text editor of your choice (i.e. VSCode).")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Flow-Serverless-React-Boilerplate")," will create a new starter project which will provide us with all the necessary boilerplate to build a Flow app without needing a backend. The folder structure is organized as follows:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"/flow.json")," - Configuration file to help manage local, testnet, and mainnet Flow deployments of contracts from the ",(0,o.kt)("inlineCode",{parentName:"li"},"/cadence")," folder."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"/cadence"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"/contracts")," - Smart contracts that can be deployed to the Flow blockchain."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"/transactions")," - Transactions that can perform changes to data on the Flow blockchain."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"/scripts")," - Scripts that can provide read-only access to data on the Flow blockchain."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"/web")," - A simple create-react-app that is integrated with the ",(0,o.kt)("inlineCode",{parentName:"li"},"Flow Client Library")," (FCL) to allow a user to log in with their Flow account and execute scripts and transactions from the aforementioned transactions and scripts folders.")),(0,o.kt)("p",null,"Once you have installed and configured these tools, you are ready to start building your composable app on Flow. The next step is to write the contracts that will serve as the foundation for the app."),(0,o.kt)("h2",{id:"cadence-development"},"Cadence Development"),(0,o.kt)("p",null,"In this section, we will walk through the process of creating a Cadence contract for a showcase, and how to interact with that contract using transactions and scripts."),(0,o.kt)("h3",{id:"contract-creation"},"Contract Creation"),(0,o.kt)("p",null,"The next step in building our composable app is to write a new contract for ",(0,o.kt)("inlineCode",{parentName:"p"},"Flowcase"),". This contract will serve as the foundation for the app and provide a way for users to create and interact with our new NFT showcases."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"The Flowcase contract")),(0,o.kt)("p",null,"In the ",(0,o.kt)("inlineCode",{parentName:"p"},"flowcase/cadence/contracts")," folder, create a new empty File named ",(0,o.kt)("inlineCode",{parentName:"p"},"flowcase.cdc"),". Fill in the contract with the following to start:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'import NonFungibleToken from "./NonFungibleToken.cdc"\n\npublic contract Flowcase {\n    /* Initialization */\n  init() {}\n\n    /* Structs and Resources */\n\n}\n')),(0,o.kt)("p",null,"Our showcase will serve as a read-only grouping of NFTs stored in a user\u2019s Flow account. Since we don\u2019t plan to  move around the actual NFTs in our showcase, we can use a struct to represent our ",(0,o.kt)("inlineCode",{parentName:"p"},"Showcase")," data store, and hold a list of ",(0,o.kt)("inlineCode",{parentName:"p"},"NFTPointer")," structs to reference to where in the account the showcase NFTs exist. "),(0,o.kt)("p",null,"Below the comment that says ",(0,o.kt)("inlineCode",{parentName:"p"},"Structs and Resources"),", we can implement our ",(0,o.kt)("inlineCode",{parentName:"p"},"Showcase")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"NFTPointer")," like the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"pub struct NFTPointer {\n    pub let id: UInt64\n    pub let collection: Capability<&{NonFungibleToken.CollectionPublic}>\n\n    init(id: UInt64, collection: Capability<&{NonFungibleToken.CollectionPublic}>) {\n        self.id = id\n        self.collection = collection\n    }\n}\n\npub struct Showcase {\n    pub let name: String\n    priv let nfts: [NFTPointer]\n\n    init(name: String, nfts: [NFTPointer]) {\n        self.name = name\n        self.nfts = nfts\n    }\n\n    pub fun getNFTs(): [NFTPointer] {\n        return self.nfts\n    }\n}\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"NFTPointer")," struct consists of two fields. The ",(0,o.kt)("inlineCode",{parentName:"p"},"collection")," field is a capability that points to a user's public NFT collection, while the ",(0,o.kt)("inlineCode",{parentName:"p"},"id")," field represents the specific NFT ID within that collection."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Showcase")," struct includes a name and description for display purposes, as well as a list of ",(0,o.kt)("inlineCode",{parentName:"p"},"NFTPointer")," structs to represent the NFTs in the showcase."),(0,o.kt)("p",null,"However, since we can't store structs directly on a Flow account, we'll need to create a ",(0,o.kt)("inlineCode",{parentName:"p"},"resource")," called ",(0,o.kt)("inlineCode",{parentName:"p"},"ShowcaseCollection")," to manage and store the ",(0,o.kt)("inlineCode",{parentName:"p"},"Showcase")," structs. This resource will be responsible for handling the creation and deletion of showcases, as well as adding and removing NFTs from them."),(0,o.kt)("p",null,"After defining the ",(0,o.kt)("inlineCode",{parentName:"p"},"Showcase")," struct, we can create a resource named ",(0,o.kt)("inlineCode",{parentName:"p"},"ShowcaseCollection")," that manages and stores the showcases in a user's account."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ShowcaseCollection")," resource has a similar implementation to an NFT collection resource, but there are some differences to note:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The type for showcases in this collection is ",(0,o.kt)("inlineCode",{parentName:"li"},"{String: Showcase}"),", which means that we use the showcase's name as a key to ensure uniqueness within a single showcase collection. Unlike NFT collections, we don't need to use the ",(0,o.kt)("inlineCode",{parentName:"li"},"@")," notation to store the data because our ",(0,o.kt)("inlineCode",{parentName:"li"},"Showcase")," struct is not a resource."),(0,o.kt)("li",{parentName:"ul"},"Instead of ",(0,o.kt)("inlineCode",{parentName:"li"},"deposit")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"withdraw")," functions, we have ",(0,o.kt)("inlineCode",{parentName:"li"},"addShowcase")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"removeShowcase")," functions to modify the showcases stored in the collection."),(0,o.kt)("li",{parentName:"ul"},"We use a ",(0,o.kt)("inlineCode",{parentName:"li"},"ShowcaseCollectionPublic")," resource interface to expose public capabilities that allow others to view the details of the showcases.")),(0,o.kt)("p",null,"Here is the code for the ",(0,o.kt)("inlineCode",{parentName:"p"},"ShowcaseCollection")," resource:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"pub event ShowcaseAdded(name: String, to: Address?)\npub event ShowcaseRemoved(name: String)\n\npub resource interface ShowcaseCollectionPublic {\n    pub fun getShowcases(): {String: Showcase}\n    pub fun getShowcase(name: String): Showcase?\n}\n\npub resource ShowcaseCollection: ShowcaseCollectionPublic {\n    pub let showcases: {String: Showcase}\n\n    init() {\n        self.showcases = {}\n    }\n\n    pub fun addShowcase(name: String, nfts: [NFTPointer]) {\n        emit ShowcaseAdded(name: name, to: self.owner?.address)\n        self.showcases[name] = Showcase(name: name, nfts: nfts)\n    }\n\n    pub fun removeShowcase(name: String) {\n        self.showcases.remove(key: name)\n    }\n\n    pub fun getShowcases(): {String: Showcase} {\n        return self.showcases\n    }\n\n    pub fun getShowcase(name: String): Showcase? {\n        return self.showcases[name]\n    }\n}\n\npub fun createShowcaseCollection(): @ShowcaseCollection {\n    return <-create ShowcaseCollection()\n}\n")),(0,o.kt)("p",null,"With the ",(0,o.kt)("inlineCode",{parentName:"p"},"Showcase"),"struct and ",(0,o.kt)("inlineCode",{parentName:"p"},"ShowcaseCollection")," resource, we now have everything we need to create and store showcases in a Flow account."),(0,o.kt)("h3",{id:"flowcase-transactions"},"Flowcase Transactions"),(0,o.kt)("p",null,"Add Showcase"),(0,o.kt)("p",null,"To allow any user to  create a new showcase, create a new file in the ",(0,o.kt)("inlineCode",{parentName:"p"},"cadence/transactions")," folder named ",(0,o.kt)("inlineCode",{parentName:"p"},"createShowcase.cdc")," and fill it in with the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"import NonFungibleToken from 0xNONFUNGIBLETOKEN\nimport Flowcase from 0xFLOWCASE\n\ntransaction(showcaseName: String, publicPaths: [PublicPath], nftIDs: [UInt64]) {\n    let showcaseCollection: &Flowcase.ShowcaseCollection\n    let showcaseAccount: PublicAccount\n\n    prepare(signer: AuthAccount) {\n        /* Initialization code goes here */\n    }\n\n    execute {\n        /* Execution code goes here */\n    }\n}\n")),(0,o.kt)("p",null,"This transaction allows any user to create a new showcase, which can store NFTs from different collections. To enable this, we're importing two contracts: the ",(0,o.kt)("inlineCode",{parentName:"p"},"NonFungibleToken")," contract that we'll use to interact with NFTs, and our own ",(0,o.kt)("inlineCode",{parentName:"p"},"Flowcase")," contract that we'll use to create and store showcases."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"createShowcase")," transaction takes three arguments:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"showcaseName"),": a unique label for the new showcase."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"publicPaths"),": an array of ",(0,o.kt)("inlineCode",{parentName:"li"},"PublicPath")," objects representing the NFT collection paths where the NFTs that will be added to the showcase are stored."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"nftIDs"),": an array of UInt64 values representing the IDs of the NFTs that will be added to the showcase.")),(0,o.kt)("p",null,"In the ",(0,o.kt)("inlineCode",{parentName:"p"},"prepare")," statement, the ",(0,o.kt)("inlineCode",{parentName:"p"},"signer")," AuthAccount is available as a parameter. This means the transaction expects a single user to sign it, and whoever signs the transaction will be providing the account where the new showcase will be stored."),(0,o.kt)("p",null,"To initialize data for the prepare statement, we can replace the ",(0,o.kt)("inlineCode",{parentName:"p"},"/* Initialization code goes here */")," code with the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'// Initialize data for the prepare statement\nif signer.borrow<&Flowcase.ShowcaseCollection>(from: /storage/flowcaseCollection) == nil {\n    // If the showcase collection does not exist for this account, create a new one\n    let collection <- Flowcase.createShowcaseCollection()\n    signer.save(<-collection, to: /storage/flowcaseCollection)\n}\n\n// Expose the showcase collection publicly so it can be queried\nsigner.link<&{Flowcase.ShowcaseCollectionPublic}>(/public/flowcaseCollection, target: /storage/flowcaseCollection)\n\n// Borrow a reference to the showcase collection\nself.showcaseCollection = signer.borrow<&Flowcase.ShowcaseCollection>(from: /storage/flowcaseCollection) ??\n    panic("Could not borrow a reference to the Flowcase ShowcaseCollection")\n\n// Get the signer\'s account\nself.showcaseAccount = getAccount(signer.address)\n')),(0,o.kt)("p",null,"In the prepare statement, we first check if the ",(0,o.kt)("inlineCode",{parentName:"p"},"showcaseCollection")," exists for the signer's account, and if it doesn't, we create a new one. The ",(0,o.kt)("inlineCode",{parentName:"p"},"createShowcaseCollection")," function is a custom function defined in the ",(0,o.kt)("inlineCode",{parentName:"p"},"Flowcase")," contract that creates a new ",(0,o.kt)("inlineCode",{parentName:"p"},"ShowcaseCollection")," resource. We then save this new ",(0,o.kt)("inlineCode",{parentName:"p"},"ShowcaseCollection")," resource to the signer's account storage."),(0,o.kt)("p",null,"Next, we expose the ",(0,o.kt)("inlineCode",{parentName:"p"},"ShowcaseCollectionPublic")," interface publicly so that anyone can query the showcase collection using the account's public address."),(0,o.kt)("p",null,"After that, we borrow a reference to the ",(0,o.kt)("inlineCode",{parentName:"p"},"ShowcaseCollection")," resource from storage so that we can add new showcases to it."),(0,o.kt)("p",null,"Finally, we get the ",(0,o.kt)("inlineCode",{parentName:"p"},"showcaseAccount")," of the signer, which is the account that will be used to store the new showcase."),(0,o.kt)("p",null,"Overall, this code is responsible for setting up the ",(0,o.kt)("inlineCode",{parentName:"p"},"showcaseCollection")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"showcaseAccount")," for the transaction, and exposing the necessary functionality so that the transaction can create new showcases."),(0,o.kt)("p",null,"For the ",(0,o.kt)("inlineCode",{parentName:"p"},"/* Execution here */")," block, we can replace it with the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"// initialize an array to hold the NFTs that will be included in the showcase\nvar showcaseNFTs: [Flowcase.NFTPointer] = []\n\n// iterate over the list of public paths and corresponding NFT IDs\nvar i = 0\nwhile (i < publicPaths.length) {\n    let publicPath = publicPaths[i]\n    let nftID = nftIDs[i]\n\n        // Add a new NFTPointer struct to the array of NFTs\n    showcaseNFTs.append(Flowcase.NFTPointer(id: nftID, collection: self.showcaseAccount.getCapability<&{NonFungibleToken.CollectionPublic}>(publicPath)))\n    i = i + 1\n}\n\nself.showcaseCollection.addShowcase(name: showcaseName, nfts: showcaseNFTs)\n")),(0,o.kt)("p",null,"In this section, we initialize an empty array called ",(0,o.kt)("inlineCode",{parentName:"p"},"showcaseNFTs"),", which will hold the ",(0,o.kt)("inlineCode",{parentName:"p"},"NFTPointer"),"structs that make up the showcase's NFTs. Then we iterate over the ",(0,o.kt)("inlineCode",{parentName:"p"},"publicPaths"),"\nand ",(0,o.kt)("inlineCode",{parentName:"p"},"nftIDs"),"parameters to create new ",(0,o.kt)("inlineCode",{parentName:"p"},"NFTPointer"),"structs for each NFT to be added to the showcase. Finally, we call the ",(0,o.kt)("inlineCode",{parentName:"p"},"addShowcase"),"function on the ",(0,o.kt)("inlineCode",{parentName:"p"},"showcaseCollection"),"to create the new showcase and add the NFTs to it."),(0,o.kt)("p",null,"Remove Showcase"),(0,o.kt)("p",null,"To remove a showcase, we can create a new transaction in the ",(0,o.kt)("inlineCode",{parentName:"p"},"cadence/transactions")," folder named ",(0,o.kt)("inlineCode",{parentName:"p"},"removeShowcase.cdc"),". This transaction can be filled in with the following code:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'import Flowcase from 0xFLOWCASE\n\ntransaction(showcaseName: String) {\n    let flowcase: &Flowcase.ShowcaseCollection\n\n    prepare(signer: AuthAccount) {\n                // Get a reference to the signed account\'s stored showcase collection\n        self.flowcase = signer.borrow<&Flowcase.ShowcaseCollection>(from: /storage/flowcaseCollection) ??\n            panic("Could not borrow a reference to the Flowcase")\n    }\n\n    execute {\n                // Call removeShowcase on the stored showcase collection reference\n        self.flowcase.removeShowcase(name: showcaseName)\n    }\n}\n')),(0,o.kt)("p",null,"In this script, we accept a ",(0,o.kt)("inlineCode",{parentName:"p"},"showcaseName"),"parameter as input. We get a reference to the signed account's stored ",(0,o.kt)("inlineCode",{parentName:"p"},"Flowcase.ShowcaseCollection")," in the ",(0,o.kt)("inlineCode",{parentName:"p"},"prepare"),"block. In the ",(0,o.kt)("inlineCode",{parentName:"p"},"execute"),"\nblock, we call the ",(0,o.kt)("inlineCode",{parentName:"p"},"removeShowcase")," function on the stored ",(0,o.kt)("inlineCode",{parentName:"p"},"showcaseCollectionRef")," using the inputted ",(0,o.kt)("inlineCode",{parentName:"p"},"showcaseName"),". This will remove the showcase with the inputted name from the stored ",(0,o.kt)("inlineCode",{parentName:"p"},"Flowcase.ShowcaseCollection"),"."),(0,o.kt)("h3",{id:"flowcase-scripts"},"Flowcase scripts"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"}," Get Showcases Script\n")),(0,o.kt)("p",null,"In the ",(0,o.kt)("inlineCode",{parentName:"p"},"cadence/scripts")," folder, create a new file called ",(0,o.kt)("inlineCode",{parentName:"p"},"getShowcases.cdc")),(0,o.kt)("p",null,"We can use the following code to fill in ",(0,o.kt)("inlineCode",{parentName:"p"},"getShowcases.cdc")," in order to retrieve showcase information from an account:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'import NonFungibleToken from 0xNONFUNGIBLETOKENADDRESS\nimport MetadataViews from 0xMETADATAVIEWSADDRESS\nimport Flowcase from 0xFLOWCASEADDRESS\n\npub fun main(address: Address): {String: [AnyStruct]}? {\n    let account = getAccount(address)\n    var nfts: [AnyStruct] = []\n    let flowcaseCap = account.getCapability<&{Flowcase.ShowcaseCollectionPublic}>(/public/flowcaseCollection)\n        .borrow()\n\n    if flowcaseCap != nil {\n        let showcases = flowcaseCap!.getShowcases()\n        let allShowcases: {String: [AnyStruct]} = {}\n        for showcaseName in showcases.keys {\n            let nfts: [AnyStruct] = []\n            let showcase = showcases[showcaseName]!\n            let nftCaps = showcase.getNFTs()\n            for nftPointer in nftCaps {\n                let borrowedNFT = nftPointer.collection.borrow()!.borrowNFT(id: nftPointer.id)\n                let displayView = borrowedNFT.resolveView(Type<MetadataViews.Display>())\n                let nftView: AnyStruct = {\n                    "nftID": borrowedNFT.id,\n                    "display": displayView,\n                    "type": borrowedNFT.getType().identifier\n                }\n                nfts.append(nftView)\n            }\n            allShowcases[showcaseName] = nfts\n        }\n        return allShowcases\n    }\n    return {}\n}\n')),(0,o.kt)("p",null,"This script takes in an account address and will retrieve the public ShowcaseCollection we had initialized earlier in the createShowcase transaction. If it doesn\u2019t exist in the passed in account, the script will simply return an empty map, indicating an empty showcase collection."),(0,o.kt)("p",null,"If there is a showcase, the script will navigate into the showcase, extract all of the NFTs from it, and try to get the details of the contained NFTs with the following: ",(0,o.kt)("inlineCode",{parentName:"p"},"let borrowedNFT = nftPointer.collection.borrow()!.borrowNFT(id: nftPointer.id)")),(0,o.kt)("p",null,"The script then aggregates all of the results in a dictionary data store to create a structure that looks like the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'{\n   "My Showcase\'s Name!": [\n        {\n          "nftID": 1234,\n        "display": {\n                    "title": "NFT\'s display title will show here"\n                    "thumbnail": { "url": "URL to NFT\'s image here" }\n                },\n                "type": "A.41231234.MyFunNFT.NFT"\n      },\n            ...\n   ]\n')),(0,o.kt)("p",null,"Here, ",(0,o.kt)("inlineCode",{parentName:"p"},"nftID")," represents the ID of the NFT, ",(0,o.kt)("inlineCode",{parentName:"p"},"display")," is a struct with the NFT\u2019s display information (title and thumbnail), and ",(0,o.kt)("inlineCode",{parentName:"p"},"type")," represents the NFT's type."),(0,o.kt)("h3",{id:"flow-configuration"},"Flow Configuration"),(0,o.kt)("p",null,"In the root directory of the project, you will find a file called ",(0,o.kt)("inlineCode",{parentName:"p"},"flow.json"),". This file provides configurations that tell the flow CLI and other programs how to find the contracts you\u2019ve created and how they should be deployed."),(0,o.kt)("p",null,"To add the ",(0,o.kt)("inlineCode",{parentName:"p"},"Flowcase"),"contract that we created earlier, we need to update the ",(0,o.kt)("inlineCode",{parentName:"p"},"contracts"),"\nsection of ",(0,o.kt)("inlineCode",{parentName:"p"},"flow.json"),". You can do this by adding the following configuration:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'{\n    "contracts": {\n        "Flowcase": {\n            "source": "cadence/contracts/Flowcase.cdc",\n            "aliases": {\n                "testnet": "0xad34354eb0c6ab2a"\n            }\n        },\n        "MyFunNFT": ...\n     },\n     ...\n}\n')),(0,o.kt)("p",null,"Here, we define ",(0,o.kt)("inlineCode",{parentName:"p"},"Flowcase")," as a smart contract and specify that its source code is located in ",(0,o.kt)("inlineCode",{parentName:"p"},"cadence/contracts/Flowcase.cdc"),". Additionally, we define an ",(0,o.kt)("inlineCode",{parentName:"p"},"alias")," for ",(0,o.kt)("inlineCode",{parentName:"p"},"Flowcase"),", which is an optional configuration that tells the Flow CLI and other programs to use a specific address for the contract when deploying or interacting with it. In this case, we're using the address ",(0,o.kt)("inlineCode",{parentName:"p"},"0xad34354eb0c6ab2a")," for the ",(0,o.kt)("inlineCode",{parentName:"p"},"testnet")," environment. If you're using a different network or want to deploy the ",(0,o.kt)("inlineCode",{parentName:"p"},"Flowcase")," contract to a different address, you'll need to update this configuration accordingly."),(0,o.kt)("p",null,"With this configuration in place, the Flow CLI and other programs will be able to find and interact with the ",(0,o.kt)("inlineCode",{parentName:"p"},"Flowcase")," contract that we created."),(0,o.kt)("h2",{id:"front-end-development"},"Front-End Development"),(0,o.kt)("p",null,"Now that we have all of the necessary contracts, transactions, and scripts in place, we can begin building a front-end application. The starter template provides a basic React application in the ",(0,o.kt)("inlineCode",{parentName:"p"},"web")," folder. To get started with adding showcases to the front-end, navigate to the ",(0,o.kt)("inlineCode",{parentName:"p"},"web")," folder with the command ",(0,o.kt)("inlineCode",{parentName:"p"},"cd web")," and install the required dependencies using ",(0,o.kt)("inlineCode",{parentName:"p"},"npm install"),"."),(0,o.kt)("p",null,"Once the installation is complete, run ",(0,o.kt)("inlineCode",{parentName:"p"},"npm start")," to start a local server hosting the front-end. This should start a web server running on ",(0,o.kt)("inlineCode",{parentName:"p"},"localhost:3000"),". Open a web browser and go to ",(0,o.kt)("a",{parentName:"p",href:"http://localhost:3000/"},"http://localhost:3000")," to view the front-end that we will be working on."),(0,o.kt)("p",null,'In the starter template, the React app is set up to point to the testnet and allows you to connect a testnet Flow wallet. Click on "Connect Wallet" to connect a wallet of your choice. For example, you can use Blocto for a first-time use.'),(0,o.kt)("p",null,"After you have connected your wallet, you will see a button that allows you to mint a new NFT. Click the button and follow the steps to mint a new NFT. Repeat this step at least twice to create multiple NFTs in your account, which will be useful when we create showcases."),(0,o.kt)("p",null,"After running the transactions to mint NFTs, you can refresh the page to see your new NFTs listed under the ",(0,o.kt)("inlineCode",{parentName:"p"},"My NFTs")," header. All of the code that powers this page can be found in the ",(0,o.kt)("inlineCode",{parentName:"p"},"App")," component located in ",(0,o.kt)("inlineCode",{parentName:"p"},"web/src/App.js"),"."),(0,o.kt)("h3",{id:"creating-a-new-showcase"},"Creating a new showcase"),(0,o.kt)("p",null,"Let's modify the ",(0,o.kt)("inlineCode",{parentName:"p"},"App.js")," file to support creating a new showcase using the NFTs that are minted in the current wallet."),(0,o.kt)("p",null,"First, replace the following import at the top of the ",(0,o.kt)("inlineCode",{parentName:"p"},"App.js")," file:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"import { getNFTsFromAccount } from './cadut/scripts';\nimport { mintNFT } from './cadut/transactions';\n")),(0,o.kt)("p",null,"with the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"import { mintNFT, createShowcase } from './cadut/transactions';\n")),(0,o.kt)("p",null,"This will import our previously created ",(0,o.kt)("inlineCode",{parentName:"p"},"createShowcase")," transaction from the ",(0,o.kt)("inlineCode",{parentName:"p"},"cadut")," folder to the React app. The template that we are using will automatically copy over the transactions and scripts we created earlier into the ",(0,o.kt)("inlineCode",{parentName:"p"},"cadut")," folder using the open source ",(0,o.kt)("inlineCode",{parentName:"p"},"[flow-cadut](https://github.com/onflow/flow-cadut)")," module."),(0,o.kt)("p",null,"To create our showcase, we need to provide three parameters to ",(0,o.kt)("inlineCode",{parentName:"p"},"createShowcase"),", which are:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"transaction(showcaseName: String, publicPaths: [PublicPath], nftIDs: [UInt64])\n")),(0,o.kt)("p",null,"We need to get a name for the new showcase from the user and allow them to select one or many of their owned NFTs to provide values for ",(0,o.kt)("inlineCode",{parentName:"p"},"publicPaths")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"nftIDs"),"."),(0,o.kt)("p",null,"Here are the steps to create a new showcase:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"First, we need to add a state to hold the showcase name. We can create an initial state for showcase name at the top of our ",(0,o.kt)("inlineCode",{parentName:"p"},"App")," function:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},'function App() {\n  const [showcaseName, setShowcaseName] = useState("");\n  // ...\n}\n'))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Next, we need to modify the ",(0,o.kt)("inlineCode",{parentName:"p"},"myNFTs")," array to include a ",(0,o.kt)("inlineCode",{parentName:"p"},"selected")," field that we will use to allow the user to select which NFTs they want to include in the showcase. To do this, we can modify the ",(0,o.kt)("inlineCode",{parentName:"p"},"setMyNFTs")," call in the ",(0,o.kt)("inlineCode",{parentName:"p"},"useEffect")," hook to include the ",(0,o.kt)("inlineCode",{parentName:"p"},"selected")," field:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"setMyNFTs(myNFTs[0].map(nft => ({ ...nft, selected: false })));\n")),(0,o.kt)("p",{parentName:"li"},"This initializes all NFTs in ",(0,o.kt)("inlineCode",{parentName:"p"},"myNFTs")," with a ",(0,o.kt)("inlineCode",{parentName:"p"},"selected")," field set to ",(0,o.kt)("inlineCode",{parentName:"p"},"false"),".")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"We now need to add a checkbox for each NFT that allows the user to select which NFTs they want to include in the showcase. To do this, we can modify the code that renders the NFTs:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},'myNFTs.map((curNFT, i) => {\n  return \n    <div key={i}>\n      <h4 style={{ marginBottom: "2px" }}>NFT {i + 1}</h4>\n      <NFTView {...curNFT} />\n      <label>\n        <input\n          type="checkbox"\n          checked={myNFTs[i].selected}\n          onChange={e => {\n            const newNFTs = [...myNFTs];\n            newNFTs[i].selected = e.target.checked;\n            setMyNFTs(newNFTs);\n          }}\n        />\n        Select for showcase\n      </label>\n    </div>\n  );\n});\n')),(0,o.kt)("p",{parentName:"li"},"This adds a checkbox for each NFT that is initially unchecked. When a checkbox is clicked, the corresponding ",(0,o.kt)("inlineCode",{parentName:"p"},"selected")," field for the NFT is updated.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Below the above code for NFTs, we can place the following to set a showcaseName and create a new showcase:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},'<form>\n  <br />\n  <input type="text" value={showcaseName} onChange={(e) => setShowcaseName(e.target.value)} placeholder="Enter Showcase Name" />\n  <button type="button" onClick={async () => {\n      const selectedNFTs = myNFTs.filter((nft) => {\n        return nft.selected\n      })\n      await createShowcase({\n        args: [\n          showcaseName,\n          selectedNFTs.map((nft) => `/public/${nft.publicPath.identifier}`),\n          selectedNFTs.map((nft) => nft.nftID)\n        ],\n        signers: [fcl.authz],\n        payer: fcl.authz,\n        proposer: fcl.authz\n      })\n    }}\n  >\n    Create Showcase\n  </button>\n</form>\n')),(0,o.kt)("p",{parentName:"li"},"The input will allow for a showcase name to be set by the user, and when the ",(0,o.kt)("inlineCode",{parentName:"p"},"Create Showcase")," button is clicked, we will filter our NFT list for the selected ones to fill in our createShowcase arguments. Additionally, we use the default ",(0,o.kt)("inlineCode",{parentName:"p"},"fcl.authz")," to fill in signers, payer, and proposer arguments to our createShowcase transaction to allow the user\u2019s wallet to run the transaction.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"We now have everything needed to create a showcase. The user can select some NFTs they minted, set a name for their showcase, and run the ",(0,o.kt)("inlineCode",{parentName:"p"},"createShowcase")," transaction by clicking the \u201cCreate Showcase\u201d button."))),(0,o.kt)("h3",{id:"view-showcases"},"View Showcases"),(0,o.kt)("p",null,"Now that we can create a showcase, we don\u2019t have a way to view that the showcase was created, so next up we will figure out how to view showcases for an account. For viewing showcases, we can follow these steps:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Create a new React component called ",(0,o.kt)("inlineCode",{parentName:"li"},"Showcases.js")," in the ",(0,o.kt)("inlineCode",{parentName:"li"},"web/src")," folder. This component will be responsible for displaying all showcases owned by an account and will also allow the user to delete a showcase. Add the following code to the component file, and we can go over what\u2019s going on in the following sections:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"import { useState, useEffect } from 'react';\nimport * as fcl from \"@onflow/fcl\";\nimport { getShowcases } from './cadut/scripts';\nimport { removeShowcase } from './cadut/transactions';\nimport NFTView from './NFTView';\n\nfunction Showcases({ user }) {\n  const [showcases, setShowcases] = useState([]);\n\n  return (\n    <div>\n      <h3>Showcases:</h3>\n    </div>\n  );\n}\n\nexport default Showcases\n")),(0,o.kt)("p",null,"This snippet will import our getShowcases and removeShowcase script and transaction which we can use to populate the page with created showcases from an account and later allow for deletion of a showcase. It also will set up a value for an input called ",(0,o.kt)("inlineCode",{parentName:"p"},"showcaseInput"),", which will be where we can store a user inputted Flow account address we want to view showcases from. The ",(0,o.kt)("inlineCode",{parentName:"p"},"showcases")," state variable will be used to store all resulting showcases coming out of the given address."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Back in ",(0,o.kt)("inlineCode",{parentName:"li"},"App.js"),", lets add the following below our \u201cCreate Showcase\u201d form to show our new showcases component:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"...\n<hr />\n<Showcases user={user} />\n...\n")),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Return back to ",(0,o.kt)("inlineCode",{parentName:"li"},"Showcases.js"),". Below our state initialization, we can use the following code to help us retrieve some initial showcases for the logged in account:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"...\nconst [showcases, setShowcases] = useState([])\n\nuseEffect(() => {\n  const run = async () => {\n    if (user.loggedIn) {\n      getShowcasesForAddress(fcl.withPrefix(user.addr))\n    }\n  }\n  run()\n}, [user])\n\nconst getShowcasesForAddress = async (address) => {\n  const showcases = await getShowcases({\n    args: [address],\n  });\n  setShowcases(showcases[0] || [])\n}\n\n...\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"useEffect")," above will make it so if a user connects their wallet, we will set the address we want to retrieve to that user\u2019s address. Additionally, we will call ",(0,o.kt)("inlineCode",{parentName:"p"},"getShowcasesForAddress")," "),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"getShowcasesForAddress")," is a new function that calls our previously written cadence script and provides the given address as an argument. Our result from the script is then stored in the ",(0,o.kt)("inlineCode",{parentName:"p"},"showcases")," object with the ",(0,o.kt)("inlineCode",{parentName:"p"},"setShowcases")," call."),(0,o.kt)("p",null,"Now we have a way to retrieve showcases given our logged in flow account, and we are retrieving showcases from the chain when a user connects their wallet."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"To finish off, we need a way to show the\xa0retrieved showcases on the page. To do this, we can replace the piece of code with ",(0,o.kt)("inlineCode",{parentName:"li"},"<h3>Showcases:</h3>")," with the following snippet:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"<h3>Showcases:</h3>\n<div>\n  {\n    Object.keys(showcases).map((showcaseName, i) => {\n      return (\n        <div key={showcaseName}>\n          <h4 style={{marginBottom: '2px'}}>\n            Showcase {i+1} - {showcaseName}\n            <br />\n            {Object.keys(showcases[showcaseName]).length} NFTs\n          </h4>\n          {\n            showcases[showcaseName].map((nft, i) => {\n              return <NFTView key={`${showcaseName}-${i}`} { ...nft }/>\n            })\n          }\n        </div>\n      )\n    })\n  }\n  {Object.keys(showcases).length === 0 && <div>No showcases in account</div>}\n</div>\n")),(0,o.kt)("p",null,"This code will loop through our resulting showcases, and display the name of the showcase followed by looping through the nfts within the showcase, and showcasing them using the already existing ",(0,o.kt)("inlineCode",{parentName:"p"},"NFTView")," provided by the template. "),(0,o.kt)("p",null,"If no showcases were found and our showcase object does not have any data in it, we will let the user know that there were no showcases."),(0,o.kt)("p",null,"Now if you refresh your page, you should see the showcase created earlier populated on the screen, and the last feature we need to support on this UI is a way to remove a showcase from our account."),(0,o.kt)("h3",{id:"removing-a-showcase"},"Removing a showcase"),(0,o.kt)("p",null,"To remove a showcase from the marketplace, you can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"removeShowcase"),'\ntransaction function you have previously imported in the Showcase component. To enable the removal of a showcase, you can add a "Remove showcase" button next to each showcase view using the following code snippet:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"Object.keys(showcases).map((showcaseName, i) => {\n    return (\n      <div key={showcaseName}>\n        <h4 style={{marginBottom: '2px'}}>\n          Showcase {i+1} - {showcaseName}\n          <br />\n          {Object.keys(showcases[showcaseName]).length} NFTs\n        </h4>\n        {\n          showcases[showcaseName].map((nft, i) => {\n            return <NFTView key={`${showcaseName}-${i}`} { ...nft }/>\n          })\n        }\n        <button onClick={async () => {\n          await removeShowcase({\n            args: [showcaseName],\n            signers: [fcl.authz],\n            payer: fcl.authz,\n            proposer: fcl.authz\n          })\n    \n        }}>\n          Delete this showcase\n        </button>\n      </div>\n    )\n})\n")),(0,o.kt)("p",null,'This code will iterate through each showcase and add a "Remove showcase" button next to it. When a user clicks the button, the ',(0,o.kt)("inlineCode",{parentName:"p"},"removeShowcase")," function is called with the name of the showcase as an argument. This function will call the ",(0,o.kt)("inlineCode",{parentName:"p"},"removeShowcase"),"transaction defined earlier in the component, passing in the showcase name, and removing it from the marketplace. Note that the ",(0,o.kt)("inlineCode",{parentName:"p"},"removeShowcase"),"function now takes only one argument, the showcase name. The transaction object containing the signers, payer and proposer can be defined within the ",(0,o.kt)("inlineCode",{parentName:"p"},"removeShowcase"),"function itself."),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"In this tutorial, we've walked through the process of building a showcase application on Flow, from writing a smart contract for the showcases to implementing transactions to add and remove showcases. We also showed how to retrieve showcases in a script and add, view, and remove showcases from the front-end. With this knowledge, you now have a solid foundation for building composable applications on Flow, where you can leverage existing contracts and functionality to build your own applications."))}d.isMDXComponent=!0}}]);