"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[5581],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>f});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=a.createContext({}),s=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=s(e.components);return a.createElement(c.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=s(t),h=i,f=u["".concat(c,".").concat(h)]||u[h]||d[h]||r;return t?a.createElement(f,o(o({ref:n},p),{},{components:t})):a.createElement(f,o({ref:n},p))}));function f(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=h;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l[u]="string"==typeof e?e:i,o[1]=l;for(var s=2;s<r;s++)o[s]=t[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},5665:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>f,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var a=t(87462),i=(t(67294),t(3905));const r={title:"Interfaces"},o=void 0,l={unversionedId:"cadence/language/interfaces",id:"cadence/language/interfaces",title:"Interfaces",description:"An interface is an abstract type that specifies the behavior of types",source:"@site/docs/cadence/language/interfaces.mdx",sourceDirName:"cadence/language",slug:"/cadence/language/interfaces",permalink:"/cadence/language/interfaces",draft:!1,tags:[],version:"current",lastUpdatedBy:"Tom Haile",lastUpdatedAt:1682540899,formattedLastUpdatedAt:"Apr 26, 2023",frontMatter:{title:"Interfaces"},sidebar:"tutorialSidebar",previous:{title:"Imports",permalink:"/cadence/language/imports"},next:{title:"Operators",permalink:"/cadence/language/operators"}},c={},s=[{value:"Interface Declaration",id:"interface-declaration",level:2},{value:"Interface Implementation",id:"interface-implementation",level:2},{value:"Interfaces in Types",id:"interfaces-in-types",level:2},{value:"Interface Nesting",id:"interface-nesting",level:2},{value:"Interface Default Functions",id:"interface-default-functions",level:2},{value:"Nested Type Requirements",id:"nested-type-requirements",level:2}],p=(u="Callout",function(e){return console.warn("Component "+u+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",e)});var u;const d={toc:s},h="wrapper";function f(e){let{components:n,...t}=e;return(0,i.kt)(h,(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An interface is an abstract type that specifies the behavior of types\nthat ",(0,i.kt)("em",{parentName:"p"},"implement")," the interface.\nInterfaces declare the required functions and fields,\nthe access control for those declarations,\nand preconditions and postconditions that implementing types need to provide."),(0,i.kt)("p",null,"There are three kinds of interfaces:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Structure interfaces"),": implemented by ",(0,i.kt)("a",{parentName:"li",href:"composite-types#structures"},"structures")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Resource interfaces"),": implemented by ",(0,i.kt)("a",{parentName:"li",href:"composite-types#resources"},"resources")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Contract interfaces"),": implemented by ",(0,i.kt)("a",{parentName:"li",href:"contracts"},"contracts"))),(0,i.kt)("p",null,"Structure, resource, and contract types may implement multiple interfaces."),(0,i.kt)("p",null,"There is no support for event and enum interfaces."),(0,i.kt)("p",null,"Nominal typing applies to composite types that implement interfaces.\nThis means that a type only implements an interface\nif it has explicitly declared the conformance,\nthe composite type does not implicitly conform to an interface,\neven if it satisfies all requirements of the interface."),(0,i.kt)("p",null,"Interfaces consist of the function and field requirements\nthat a type implementing the interface must provide implementations for.\nInterface requirements, and therefore also their implementations,\nmust always be at least public."),(0,i.kt)("p",null,"Variable field requirements may be annotated\nto require them to be publicly settable."),(0,i.kt)("p",null,"Function requirements consist of the name of the function,\nparameter types, an optional return type,\nand optional preconditions and postconditions."),(0,i.kt)("p",null,"Field requirements consist of the name and the type of the field.\nField requirements may optionally declare a getter requirement and a setter requirement,\neach with preconditions and postconditions."),(0,i.kt)("p",null,"Calling functions with preconditions and postconditions on interfaces\ninstead of concrete implementations can improve the security of a program,\nas it ensures that even if implementations change,\nsome aspects of them will always hold."),(0,i.kt)("h2",{id:"interface-declaration"},"Interface Declaration"),(0,i.kt)("p",null,"Interfaces are declared using the ",(0,i.kt)("inlineCode",{parentName:"p"},"struct"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"resource"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"contract")," keyword,\nfollowed by the ",(0,i.kt)("inlineCode",{parentName:"p"},"interface")," keyword,\nthe name of the interface,\nand the requirements, which must be enclosed in opening and closing braces."),(0,i.kt)("p",null,"Field requirements can be annotated to\nrequire the implementation to be a variable field, by using the ",(0,i.kt)("inlineCode",{parentName:"p"},"var")," keyword;\nrequire the implementation to be a constant field, by using the ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," keyword;\nor the field requirement may specify nothing,\nin which case the implementation may either be a variable or a constant field."),(0,i.kt)("p",null,"Field requirements and function requirements must specify the required level of access.\nThe access must be at least be public, so the ",(0,i.kt)("inlineCode",{parentName:"p"},"pub")," keyword must be provided.\nVariable field requirements can be specified to also be publicly settable\nby using the ",(0,i.kt)("inlineCode",{parentName:"p"},"pub(set)")," keyword."),(0,i.kt)("p",null,"Interfaces can be used in types.\nThis is explained in detail in the section ",(0,i.kt)("a",{parentName:"p",href:"#interfaces-in-types"},"Interfaces in Types"),".\nFor now, the syntax ",(0,i.kt)("inlineCode",{parentName:"p"},"{I}")," can be read as the type of any value that implements the interface ",(0,i.kt)("inlineCode",{parentName:"p"},"I"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cadence"},'// Declare a resource interface for a fungible token.\n// Only resources can implement this resource interface.\n//\npub resource interface FungibleToken {\n\n    // Require the implementing type to provide a field for the balance\n    // that is readable in all scopes (`pub`).\n    //\n    // Neither the `var` keyword, nor the `let` keyword is used,\n    // so the field may be implemented as either a variable\n    // or as a constant field.\n    //\n    pub balance: Int\n\n    // Require the implementing type to provide an initializer that\n    // given the initial balance, must initialize the balance field.\n    //\n    init(balance: Int) {\n        pre {\n            balance >= 0:\n                "Balances are always non-negative"\n        }\n        post {\n            self.balance == balance:\n                "the balance must be initialized to the initial balance"\n        }\n\n        // NOTE: The declaration contains no implementation code.\n    }\n\n    // Require the implementing type to provide a function that is\n    // callable in all scopes, which withdraws an amount from\n    // this fungible token and returns the withdrawn amount as\n    // a new fungible token.\n    //\n    // The given amount must be positive and the function implementation\n    // must add the amount to the balance.\n    //\n    // The function must return a new fungible token.\n    // The type `{FungibleToken}` is the type of any resource\n    // that implements the resource interface `FungibleToken`.\n    //\n    pub fun withdraw(amount: Int): @{FungibleToken} {\n        pre {\n            amount > 0:\n                "the amount must be positive"\n            amount <= self.balance:\n                "insufficient funds: the amount must be smaller or equal to the balance"\n        }\n        post {\n            self.balance == before(self.balance) - amount:\n                "the amount must be deducted from the balance"\n        }\n\n        // NOTE: The declaration contains no implementation code.\n    }\n\n    // Require the implementing type to provide a function that is\n    // callable in all scopes, which deposits a fungible token\n    // into this fungible token.\n    //\n    // No precondition is required to check the given token\'s balance\n    // is positive, as this condition is already ensured by\n    // the field requirement.\n    //\n    // The parameter type `{FungibleToken}` is the type of any resource\n    // that implements the resource interface `FungibleToken`.\n    //\n    pub fun deposit(_ token: @{FungibleToken}) {\n        post {\n            self.balance == before(self.balance) + token.balance:\n                "the amount must be added to the balance"\n        }\n\n        // NOTE: The declaration contains no implementation code.\n    }\n}\n')),(0,i.kt)("p",null,"Note that the required initializer and functions do not have any executable code."),(0,i.kt)("p",null,"Struct and resource Interfaces can only be declared directly inside contracts,\ni.e. not inside of functions.\nContract interfaces can only be declared globally and not inside contracts."),(0,i.kt)("h2",{id:"interface-implementation"},"Interface Implementation"),(0,i.kt)("p",null,"Declaring that a type implements (conforms) to an interface\nis done in the type declaration of the composite type (e.g., structure, resource):\nThe kind and the name of the composite type is followed by a colon (",(0,i.kt)("inlineCode",{parentName:"p"},":"),")\nand the name of one or more interfaces that the composite type implements."),(0,i.kt)("p",null,"This will tell the checker to enforce any requirements from the specified interfaces\nonto the declared type."),(0,i.kt)("p",null,"A type implements (conforms to) an interface if it declares\nthe implementation in its signature, provides field declarations\nfor all fields required by the interface,\nand provides implementations for all functions required by the interface."),(0,i.kt)("p",null,"The field declarations in the implementing type must match the field requirements\nin the interface in terms of name, type, and declaration kind (e.g. constant, variable)\nif given. For example, an interface may require a field with a certain name and type,\nbut leaves it to the implementation what kind the field is."),(0,i.kt)("p",null,"The function implementations must match the function requirements in the interface\nin terms of name, parameter argument labels, parameter types, and the return type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cadence"},'// Declare a resource named `ExampleToken` that has to implement\n// the `FungibleToken` interface.\n//\n// It has a variable field named `balance`, that can be written\n// by functions of the type, but outer scopes can only read it.\n//\npub resource ExampleToken: FungibleToken {\n\n    // Implement the required field `balance` for the `FungibleToken` interface.\n    // The interface does not specify if the field must be variable, constant,\n    // so in order for this type (`ExampleToken`) to be able to write to the field,\n    // but limit outer scopes to only read from the field, it is declared variable,\n    // and only has public access (non-settable).\n    //\n    pub var balance: Int\n\n    // Implement the required initializer for the `FungibleToken` interface:\n    // accept an initial balance and initialize the `balance` field.\n    //\n    // This implementation satisfies the required postcondition.\n    //\n    // NOTE: the postcondition declared in the interface\n    // does not have to be repeated here in the implementation.\n    //\n    init(balance: Int) {\n        self.balance = balance\n    }\n\n    // Implement the required function named `withdraw` of the interface\n    // `FungibleToken`, that withdraws an amount from the token\'s balance.\n    //\n    // The function must be public.\n    //\n    // This implementation satisfies the required postcondition.\n    //\n    // NOTE: neither the precondition nor the postcondition declared\n    // in the interface have to be repeated here in the implementation.\n    //\n    pub fun withdraw(amount: Int): @ExampleToken {\n        self.balance = self.balance - amount\n        return create ExampleToken(balance: amount)\n    }\n\n    // Implement the required function named `deposit` of the interface\n    // `FungibleToken`, that deposits the amount from the given token\n    // to this token.\n    //\n    // The function must be public.\n    //\n    // NOTE: the type of the parameter is `{FungibleToken}`,\n    // i.e., any resource that implements the resource interface `FungibleToken`,\n    // so any other token \u2013 however, we want to ensure that only tokens\n    // of the same type can be deposited.\n    //\n    // This implementation satisfies the required postconditions.\n    //\n    // NOTE: neither the precondition nor the postcondition declared\n    // in the interface have to be repeated here in the implementation.\n    //\n    pub fun deposit(_ token: @{FungibleToken}) {\n        if let exampleToken <- token as? ExampleToken {\n            self.balance = self.balance + exampleToken.balance\n            destroy exampleToken\n        } else {\n            panic("cannot deposit token which is not an example token")\n        }\n    }\n}\n\n// Declare a constant which has type `ExampleToken`,\n// and is initialized with such an example token.\n//\nlet token <- create ExampleToken(balance: 100)\n\n// Withdraw 10 units from the token.\n//\n// The amount satisfies the precondition of the `withdraw` function\n// in the `FungibleToken` interface.\n//\n// Invoking a function of a resource does not destroy the resource,\n// so the resource `token` is still valid after the call of `withdraw`.\n//\nlet withdrawn <- token.withdraw(amount: 10)\n\n// The postcondition of the `withdraw` function in the `FungibleToken`\n// interface ensured the balance field of the token was updated properly.\n//\n// `token.balance` is `90`\n// `withdrawn.balance` is `10`\n\n// Deposit the withdrawn token into another one.\nlet receiver: @ExampleToken <- // ...\nreceiver.deposit(<-withdrawn)\n\n// Run-time error: The precondition of function `withdraw` in interface\n// `FungibleToken` fails, the program aborts: the parameter `amount`\n// is larger than the field `balance` (100 > 90).\n//\ntoken.withdraw(amount: 100)\n\n// Withdrawing tokens so that the balance is zero does not destroy the resource.\n// The resource has to be destroyed explicitly.\n//\ntoken.withdraw(amount: 90)\n')),(0,i.kt)("p",null,"The access level for variable fields in an implementation\nmay be less restrictive than the interface requires.\nFor example, an interface may require a field to be\nat least public (i.e. the ",(0,i.kt)("inlineCode",{parentName:"p"},"pub")," keyword is specified),\nand an implementation may provide a variable field which is public,\nbut also publicly settable (the ",(0,i.kt)("inlineCode",{parentName:"p"},"pub(set)")," keyword is specified)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cadence"},"pub struct interface AnInterface {\n    // Require the implementing type to provide a publicly readable\n    // field named `a` that has type `Int`. It may be a variable\n    // or a constant field.\n    //\n    pub a: Int\n}\n\npub struct AnImplementation: AnInterface {\n    // Declare a publicly settable variable field named `a` that has type `Int`.\n    // This implementation satisfies the requirement for interface `AnInterface`:\n    // The field is at least publicly readable, but this implementation also\n    // allows the field to be written to in all scopes.\n    //\n    pub(set) var a: Int\n\n    init(a: Int) {\n        self.a = a\n    }\n}\n")),(0,i.kt)("h2",{id:"interfaces-in-types"},"Interfaces in Types"),(0,i.kt)("p",null,"Interfaces can be used in types: The type ",(0,i.kt)("inlineCode",{parentName:"p"},"{I}")," is the type of all objects\nthat implement the interface ",(0,i.kt)("inlineCode",{parentName:"p"},"I"),"."),(0,i.kt)("p",null,"This is called a ",(0,i.kt)("a",{parentName:"p",href:"restricted-types"},"restricted type"),":\nOnly the functionality (members and functions) of the interface can be used\nwhen accessing a value of such a type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare an interface named `Shape`.\n//\n// Require implementing types to provide a field which returns the area,\n// and a function which scales the shape by a given factor.\n//\npub struct interface Shape {\n    pub fun getArea(): Int\n    pub fun scale(factor: Int)\n}\n\n// Declare a structure named `Square` the implements the `Shape` interface.\n//\npub struct Square: Shape {\n    // In addition to the required fields from the interface,\n    // the type can also declare additional fields.\n    //\n    pub var length: Int\n\n    // Provided the field `area`  which is required to conform\n    // to the interface `Shape`.\n    //\n    // Since `area` was not declared as a constant, variable,\n    // field in the interface, it can be declared.\n    //\n    pub fun getArea(): Int {\n        return self.length * self.length\n    }\n\n    pub init(length: Int) {\n        self.length = length\n    }\n\n    // Provided the implementation of the function `scale`\n    // which is required to conform to the interface `Shape`.\n    //\n    pub fun scale(factor: Int) {\n        self.length = self.length * factor\n    }\n}\n\n// Declare a structure named `Rectangle` that also implements the `Shape` interface.\n//\npub struct Rectangle: Shape {\n    pub var width: Int\n    pub var height: Int\n\n    // Provided the field `area  which is required to conform\n    // to the interface `Shape`.\n    //\n    pub fun getArea(): Int {\n        return self.width * self.height\n    }\n\n    pub init(width: Int, height: Int) {\n        self.width = width\n        self.height = height\n    }\n\n    // Provided the implementation of the function `scale`\n    // which is required to conform to the interface `Shape`.\n    //\n    pub fun scale(factor: Int) {\n        self.width = self.width * factor\n        self.height = self.height * factor\n    }\n}\n\n// Declare a constant that has type `Shape`, which has a value that has type `Rectangle`.\n//\nvar shape: {Shape} = Rectangle(width: 10, height: 20)\n")),(0,i.kt)("p",null,"Values implementing an interface are assignable to variables that have the interface as their type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cadence"},"// Assign a value of type `Square` to the variable `shape` that has type `Shape`.\n//\nshape = Square(length: 30)\n\n// Invalid: cannot initialize a constant that has type `Rectangle`.\n// with a value that has type `Square`.\n//\nlet rectangle: Rectangle = Square(length: 10)\n")),(0,i.kt)("p",null,"Fields declared in an interface can be accessed\nand functions declared in an interface\ncan be called on values of a type that implements the interface."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a constant which has the type `Shape`.\n// and is initialized with a value that has type `Rectangle`.\n//\nlet shape: {Shape} = Rectangle(width: 2, height: 3)\n\n// Access the field `area` declared in the interface `Shape`.\n//\nshape.area  // is `6`\n\n// Call the function `scale` declared in the interface `Shape`.\n//\nshape.scale(factor: 3)\n\nshape.area  // is `54`\n")),(0,i.kt)("h2",{id:"interface-nesting"},"Interface Nesting"),(0,i.kt)(p,{type:"info",mdxType:"Callout"},(0,i.kt)("p",null,"\ud83d\udea7 Status: Currently only contracts and contract interfaces support nested interfaces.")),(0,i.kt)("p",null,"Interfaces can be arbitrarily nested.\nDeclaring an interface inside another does not require implementing types\nof the outer interface to provide an implementation of the inner interfaces."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a resource interface `OuterInterface`, which declares\n// a nested structure interface named `InnerInterface`.\n//\n// Resources implementing `OuterInterface` do not need to provide\n// an implementation of `InnerInterface`.\n//\n// Structures may just implement `InnerInterface`.\n//\nresource interface OuterInterface {\n\n    struct interface InnerInterface {}\n}\n\n// Declare a resource named `SomeOuter` that implements the interface `OuterInterface`.\n//\n// The resource is not required to implement `OuterInterface.InnerInterface`.\n//\nresource SomeOuter: OuterInterface {}\n\n// Declare a structure named `SomeInner` that implements `InnerInterface`,\n// which is nested in interface `OuterInterface`.\n//\nstruct SomeInner: OuterInterface.InnerInterface {}\n\n")),(0,i.kt)("h2",{id:"interface-default-functions"},"Interface Default Functions"),(0,i.kt)("p",null,"Interfaces can provide default functions:\nIf the concrete type implementing the interface does not provide an implementation\nfor the function required by the interface,\nthen the interface's default function is used in the implementation."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a struct interface `Container`,\n// which declares a default function `getCount`.\n//\nstruct interface Container {\n\n    let items: [AnyStruct]\n\n    fun getCount(): Int {\n        return self.items.length\n    }\n}\n\n// Declare a concrete struct named `Numbers` that implements the interface `Container`.\n//\n// The struct does not implement the function `getCount` of the interface `Container`,\n// so the default function for `getCount` is used.\n//\nstruct Numbers: Container {\n    let items: [AnyStruct]\n\n    init() {\n        self.items = []\n    }\n}\n\nlet numbers = Numbers()\nnumbers.getCount()  // is 0\n")),(0,i.kt)("p",null,"Interfaces cannot provide default initializers or default destructors."),(0,i.kt)("p",null,"Only one conformance may provide a default function."),(0,i.kt)("h2",{id:"nested-type-requirements"},"Nested Type Requirements"),(0,i.kt)(p,{type:"info",mdxType:"Callout"},(0,i.kt)("p",null,"\ud83d\udea7 Status: Currently only contracts and contract interfaces support nested type requirements.")),(0,i.kt)("p",null,"Interfaces can require implementing types to provide concrete nested types.\nFor example, a resource interface may require an implementing type to provide a resource type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cadence"},"// Declare a resource interface named `FungibleToken`.\n//\n// Require implementing types to provide a resource type named `Vault`\n// which must have a field named `balance`.\n//\nresource interface FungibleToken {\n    pub resource Vault {\n        pub balance: Int\n    }\n}\n// Declare a resource named `ExampleToken` that implements the `FungibleToken` interface.\n//\n// The nested type `Vault` must be provided to conform to the interface.\n//\nresource ExampleToken: FungibleToken {\n    pub resource Vault {\n        pub var balance: Int\n        init(balance: Int) {\n            self.balance = balance\n        }\n    }\n}\n")))}f.isMDXComponent=!0}}]);