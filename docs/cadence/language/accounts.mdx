---
title: Accounts
sidebar_position: 19
---

The type `Account` provides access to accounts.
Accounts are only accessed through [references](./references.mdx),
which might be [authorized](./references.mdx#authorized-references).

Account objects provide information about and allow the management of
for example the account's [storage](#account-storage), [keys](#account-keys),
and [capabilities](./capability-based-access-control.md).

```cadence
access(all)
struct Account {

    /// The address of the account.
    access(all)
    let address: Address

    /// The FLOW balance of the default vault of this account.
    access(all)
    let balance: UFix64

    /// The FLOW balance of the default vault of this account that is available to be moved.
    access(all)
    let availableBalance: UFix64

    /// The storage of the account.
    access(AccountMapping)
    let storage: Account.Storage

    /// The contracts deployed to the account.
    access(AccountMapping)
    let contracts: Account.Contracts

    /// The keys assigned to the account.
    access(AccountMapping)
    let keys: Account.Keys

    /// The inbox allows bootstrapping (sending and receiving) capabilities.
    access(AccountMapping)
    let inbox: Account.Inbox

    /// The capabilities of the account.
    access(AccountMapping)
    let capabilities: Account.Capabilities

    access(all)
    struct Storage {
        /// The current amount of storage used by the account in bytes.
        access(all)
        let used: UInt64

        /// The storage capacity of the account in bytes.
        access(all)
        let capacity: UInt64

        /// All public paths of this account.
        access(all)
        let publicPaths: [PublicPath]

        /// All storage paths of this account.
        access(all)
        let storagePaths: [StoragePath]

        /// Saves the given object into the account's storage at the given path.
        ///
        /// Resources are moved into storage, and structures are copied.
        ///
        /// If there is already an object stored under the given path, the program aborts.
        ///
        /// The path must be a storage path, i.e., only the domain `storage` is allowed.
        access(Storage | SaveValue)
        fun save<T: Storable>(_ value: T, to: StoragePath)

        /// Reads the type of an object from the account's storage which is stored under the given path,
        /// or nil if no object is stored under the given path.
        ///
        /// If there is an object stored, the type of the object is returned without modifying the stored object.
        ///
        /// The path must be a storage path, i.e., only the domain `storage` is allowed.
        access(all)
        view fun type(at path: StoragePath): Type?

        /// Loads an object from the account's storage which is stored under the given path,
        /// or nil if no object is stored under the given path.
        ///
        /// If there is an object stored,
        /// the stored resource or structure is moved out of storage and returned as an optional.
        ///
        /// When the function returns, the storage no longer contains an object under the given path.
        ///
        /// The given type must be a supertype of the type of the loaded object.
        /// If it is not, the function panics.
        ///
        /// The given type must not necessarily be exactly the same as the type of the loaded object.
        ///
        /// The path must be a storage path, i.e., only the domain `storage` is allowed.
        access(Storage | LoadValue)
        fun load<T: Storable>(from: StoragePath): T?

        /// Returns a copy of a structure stored in account storage under the given path,
        /// without removing it from storage,
        /// or nil if no object is stored under the given path.
        ///
        /// If there is a structure stored, it is copied.
        /// The structure stays stored in storage after the function returns.
        ///
        /// The given type must be a supertype of the type of the copied structure.
        /// If it is not, the function panics.
        ///
        /// The given type must not necessarily be exactly the same as the type of the copied structure.
        ///
        /// The path must be a storage path, i.e., only the domain `storage` is allowed.
        access(Storage | CopyValue)
        view fun copy<T: AnyStruct>(from: StoragePath): T?

        /// Returns true if the object in account storage under the given path satisfies the given type,
        /// i.e. could be borrowed using the given type.
        ///
        /// The given type must not necessarily be exactly the same as the type of the     borrowed object.
        ///
        /// The path must be a storage path, i.e., only the domain `storage` is allowed.
        access(all)
        view fun check<T: Any>(from: StoragePath): Bool

        /// Returns a reference to an object in storage without removing it from storage.
        ///
        /// If no object is stored under the given path, the function returns nil.
        /// If there is an object stored, a reference is returned as an optional,
        /// provided it can be borrowed using the given type.
        /// If the stored object cannot be borrowed using the given type, the function panics.
        ///
        /// The given type must not necessarily be exactly the same as the type of the borrowed object.
        ///
        /// The path must be a storage path, i.e., only the domain `storage` is allowed
        access(Storage | BorrowValue)
        view fun borrow<T: &Any>(from: StoragePath): T?

        /// Iterate over all the public paths of an account,
        /// passing each path and type in turn to the provided callback function.
        ///
        /// The callback function takes two arguments:
        ///   1. The path of the stored object
        ///   2. The run-time type of that object
        ///
        /// Iteration is stopped early if the callback function returns `false`.
        ///
        /// The order of iteration is undefined.
        ///
        /// If an object is stored under a new public path,
        /// or an existing object is removed from a public path,
        /// then the callback must stop iteration by returning false.
        /// Otherwise, iteration aborts.
        ///
        access(all)
        fun forEachPublic(_ function: fun(PublicPath, Type): Bool)

        /// Iterate over all the stored paths of an account,
        /// passing each path and type in turn to the provided callback function.
        ///
        /// The callback function takes two arguments:
        ///   1. The path of the stored object
        ///   2. The run-time type of that object
        ///
        /// Iteration is stopped early if the callback function returns `false`.
        ///
        /// If an object is stored under a new storage path,
        /// or an existing object is removed from a storage path,
        /// then the callback must stop iteration by returning false.
        /// Otherwise, iteration aborts.
        access(all)
        fun forEachStored(_ function: fun (StoragePath, Type): Bool)
    }

    access(all)
    struct Contracts {

        /// The names of all contracts deployed in the account.
        access(all)
        let names: [String]

        /// Adds the given contract to the account.
        ///
        /// The `code` parameter is the UTF-8 encoded representation of the source code.
        /// The code must contain exactly one contract or contract interface,
        /// which must have the same name as the `name` parameter.
        ///
        /// All additional arguments that are given are passed further to the initializer
        /// of the contract that is being deployed.
        ///
        /// The function fails if a contract/contract interface with the given name already exists in the account,
        /// if the given code does not declare exactly one contract or contract interface,
        /// or if the given name does not match the name of the contract/contract interface declaration in the code.
        ///
        /// Returns the deployed contract.
        access(Contracts | AddContract)
        fun add(
            name: String,
            code: [UInt8]
        ): DeployedContract

        /// Updates the code for the contract/contract interface in the account.
        ///
        /// The `code` parameter is the UTF-8 encoded representation of the source code.
        /// The code must contain exactly one contract or contract interface,
        /// which must have the same name as the `name` parameter.
        ///
        /// Does **not** run the initializer of the contract/contract interface again.
        /// The contract instance in the world state stays as is.
        ///
        /// Fails if no contract/contract interface with the given name exists in the account,
        /// if the given code does not declare exactly one contract or contract interface,
        /// or if the given name does not match the name of the contract/contract interface declaration in the code.
        ///
        /// Returns the deployed contract for the updated contract.
        access(Contracts | UpdateContract)
        fun update(name: String, code: [UInt8]): DeployedContract

        /// Returns the deployed contract for the contract/contract interface with the given name in the account, if any.
        ///
        /// Returns nil if no contract/contract interface with the given name exists in the account.
        access(all)
        view fun get(name: String): DeployedContract?

        /// Removes the contract/contract interface from the account which has the given name, if any.
        ///
        /// Returns the removed deployed contract, if any.
        ///
        /// Returns nil if no contract/contract interface with the given name exists in the account.
        access(Contracts | RemoveContract)
        fun remove(name: String): DeployedContract?

        /// Returns a reference of the given type to the contract with the given name in the account, if any.
        ///
        /// Returns nil if no contract with the given name exists in the account,
        /// or if the contract does not conform to the given type.
        access(all)
        view fun borrow<T: &Any>(name: String): T?
    }

    access(all)
    struct Keys {

        /// Adds a new key with the given hashing algorithm and a weight.
        ///
        /// Returns the added key.
        access(Keys | AddKey)
        fun add(
            publicKey: PublicKey,
            hashAlgorithm: HashAlgorithm,
            weight: UFix64
        ): AccountKey

        /// Returns the key at the given index, if it exists, or nil otherwise.
        ///
        /// Revoked keys are always returned, but they have `isRevoked` field set to true.
        access(all)
        view fun get(keyIndex: Int): AccountKey?

        /// Marks the key at the given index revoked, but does not delete it.
        ///
        /// Returns the revoked key if it exists, or nil otherwise.
        access(Keys | RevokeKey)
        fun revoke(keyIndex: Int): AccountKey?

        /// Iterate over all unrevoked keys in this account,
        /// passing each key in turn to the provided function.
        ///
        /// Iteration is stopped early if the function returns `false`.
        ///
        /// The order of iteration is undefined.
        access(all)
        fun forEach(_ function: fun(AccountKey): Bool)

        /// The total number of unrevoked keys in this account.
        access(all)
        let count: UInt64
    }

    access(all)
    struct Inbox {

        /// Publishes a new Capability under the given name,
        /// to be claimed by the specified recipient.
        access(Inbox | PublishInboxCapability)
        fun publish(_ value: Capability, name: String, recipient: Address)

        /// Unpublishes a Capability previously published by this account.
        ///
        /// Returns `nil` if no Capability is published under the given name.
        ///
        /// Errors if the Capability under that name does not match the provided type.
        access(Inbox | UnpublishInboxCapability)
        fun unpublish<T: &Any>(_ name: String): Capability<T>?

        /// Claims a Capability previously published by the specified provider.
        ///
        /// Returns `nil` if no Capability is published under the given name,
        /// or if this account is not its intended recipient.
        ///
        /// Errors if the Capability under that name does not match the provided type.
        access(Inbox | ClaimInboxCapability)
        fun claim<T: &Any>(_ name: String, provider: Address): Capability<T>?
    }

    access(all)
    struct Capabilities {

        /// The storage capabilities of the account.
        access(CapabilitiesMapping)
        let storage: Account.StorageCapabilities

        /// The account capabilities of the account.
        access(CapabilitiesMapping)
        let account: Account.AccountCapabilities

        /// Returns the capability at the given public path.
        /// Returns nil if the capability does not exist,
        /// or if the given type is not a supertype of the capability's borrow type.
        access(all)
        view fun get<T: &Any>(_ path: PublicPath): Capability<T>?

        /// Borrows the capability at the given public path.
        /// Returns nil if the capability does not exist, or cannot be borrowed using the given type.
        /// The function is equivalent to `get(path)?.borrow()`.
        access(all)
        view fun borrow<T: &Any>(_ path: PublicPath): T?

        /// Publish the capability at the given public path.
        ///
        /// If there is already a capability published under the given path, the program aborts.
        ///
        /// The path must be a public path, i.e., only the domain `public` is allowed.
        access(Capabilities | PublishCapability)
        fun publish(_ capability: Capability, at: PublicPath)

        /// Unpublish the capability published at the given path.
        ///
        /// Returns the capability if one was published at the path.
        /// Returns nil if no capability was published at the path.
        access(Capabilities | UnpublishCapability)
        fun unpublish(_ path: PublicPath): Capability?
    }

    access(all)
    struct StorageCapabilities {

        /// Get the storage capability controller for the capability with the specified ID.
        ///
        /// Returns nil if the ID does not reference an existing storage capability.
        access(Capabilities | StorageCapabilities | GetStorageCapabilityController)
        view fun getController(byCapabilityID: UInt64): &StorageCapabilityController?

        /// Get all storage capability controllers for capabilities that target this storage path
        access(Capabilities | StorageCapabilities | GetStorageCapabilityController)
        view fun getControllers(forPath: StoragePath): [&StorageCapabilityController]

        /// Iterate over all storage capability controllers for capabilities that target this storage path,
        /// passing a reference to each controller to the provided callback function.
        ///
        /// Iteration is stopped early if the callback function returns `false`.
        ///
        /// If a new storage capability controller is issued for the path,
        /// an existing storage capability controller for the path is deleted,
        /// or a storage capability controller is retargeted from or to the path,
        /// then the callback must stop iteration by returning false.
        /// Otherwise, iteration aborts.
        access(Capabilities | StorageCapabilities | GetStorageCapabilityController)
        fun forEachController(
            forPath: StoragePath,
            _ function: fun(&StorageCapabilityController): Bool
        )

        /// Issue/create a new storage capability.
        access(Capabilities | StorageCapabilities | IssueStorageCapabilityController)
        fun issue<T: &Any>(_ path: StoragePath): Capability<T>
    }

    access(all)
    struct AccountCapabilities {
        /// Get capability controller for capability with the specified ID.
        ///
        /// Returns nil if the ID does not reference an existing account capability.
        access(Capabilities | AccountCapabilities | GetAccountCapabilityController)
        view fun getController(byCapabilityID: UInt64): &AccountCapabilityController?

        /// Get all capability controllers for all account capabilities.
        access(Capabilities | AccountCapabilities | GetAccountCapabilityController)
        view fun getControllers(): [&AccountCapabilityController]

        /// Iterate over all account capability controllers for all account capabilities,
        /// passing a reference to each controller to the provided callback function.
        ///
        /// Iteration is stopped early if the callback function returns `false`.
        ///
        /// If a new account capability controller is issued for the account,
        /// or an existing account capability controller for the account is deleted,
        /// then the callback must stop iteration by returning false.
        /// Otherwise, iteration aborts.
        access(Capabilities | AccountCapabilities | GetAccountCapabilityController)
        fun forEachController(_ function: fun(&AccountCapabilityController): Bool)

        /// Issue/create a new account capability.
        access(Capabilities | AccountCapabilities | IssueAccountCapabilityController)
        fun issue<T: &Account>(): Capability<T>
    }
}

/* Storage entitlements */

entitlement Storage

entitlement SaveValue
entitlement LoadValue
entitlement CopyValue
entitlement BorrowValue

/* Contract entitlements */

entitlement Contracts

entitlement AddContract
entitlement UpdateContract
entitlement RemoveContract

/* Key entitlements */

entitlement Keys

entitlement AddKey
entitlement RevokeKey

/* Inbox entitlements */

entitlement Inbox

entitlement PublishInboxCapability
entitlement UnpublishInboxCapability
entitlement ClaimInboxCapability

/* Capability entitlements */

entitlement Capabilities

entitlement StorageCapabilities
entitlement AccountCapabilities

entitlement PublishCapability
entitlement UnpublishCapability

entitlement GetStorageCapabilityController
entitlement IssueStorageCapabilityController

entitlement GetAccountCapabilityController
entitlement IssueAccountCapabilityController

/* Entitlement mappings */

entitlement mapping AccountMapping {
    include Identity

    Storage -> SaveValue
    Storage -> LoadValue
    Storage -> CopyValue
    Storage -> BorrowValue

    Contracts -> AddContract
    Contracts -> UpdateContract
    Contracts -> RemoveContract

    Keys -> AddKey
    Keys -> RevokeKey

    Inbox -> PublishInboxCapability
    Inbox -> UnpublishInboxCapability
    Inbox -> ClaimInboxCapability

    Capabilities -> StorageCapabilities
    Capabilities -> AccountCapabilities
}

entitlement mapping CapabilitiesMapping {
    include Identity

    StorageCapabilities -> GetStorageCapabilityController
    StorageCapabilities -> IssueStorageCapabilityController

    AccountCapabilities -> GetAccountCapabilityController
    AccountCapabilities -> IssueAccountCapabilityController
}
```

### Account access

#### Performing read operations

Access to an `&Account` means having "read access" to it.
For example, the `address` and `balance` fields have the `access(all)` modifier,
so are always accessibly, which is safe because this information is public,
and the fields are read-only.

Any code can get a "read-only" reference to an account (`&Account`)
for an account address by using the built-in `getAccount` function:

```cadence
fun getAccount(_ address: Address): &Account
```

#### Performing write operation

Access to an authorized account reference (`auth(...) &Account`)
means having certain "write access" to it.

[Entitlements](./access-control.md#entitlements) authorize access to accounts.
Cadence provides both coarse-grained and fine-grained entitlements,
which decide what management functions are accessible on the account.

For example, the coarse-grained entitlement `Storage` grants access to all
storage related functions, such as `save` and `load`, which save a value to storage,
and load a value from storage respectively.

The fine-grained entitlement `AddKey` for instance,
grants access to only the `add` function of the `Account.Keys` value,
that is, it grants access to adding a key to the account.

An authorized account reference like `auth(Storage, AddKey) &Account`
therefore provides read access, as well as write access to storage,
and the ability to add a new key to that account.

[Signed transactions](./transactions.md) can get authorized account references
for each signer of the transaction that signs as an authorizer.
The `prepare` phase of the transaction can specify exactly which entitlements
it needs to perform its work.

For example, a transaction that deploys a contract to an account can be written as follows:

```cadence
transaction {
    prepare(signer: auth(AddContract) &Account) {
        signer.contracts.add(name: "MyContract", code: [/* code */])
    }
}
```

Here, the transaction requests an authorized reference with the `AddContract` entitlement.
That means that the transaction is entitled to add a contract to the account,
but is not able to add another key to the account, for example.

Script can get any kind of access to any account, using the built-in `getAuthAccount` function:

```cadence
fun getAuthAccount<T: &Account>(_ address: Address): T
```

This function is only available in scripts.
Though scripts can perform write operations,
they discard their changes upon completion.
Attempting to use this function outside of a script,
for example in a transaction,
causes a type error.

## Creating an account

The `Account` constructor allows creating new accounts.
The function requires a reference to a _payer_ account,
which should pay for the account creation.

The payer account must have enough funds to be able to create an account.
If the account does not have the required funds, the program aborts.

The constructor returns a reference to the new account
which has all coarse-grained account entitlements
(it has the type `auth(Storage, Contracts, Keys, Inbox, Capabilities) &Account`).
This provides write access to all parts fo the new account,
for example, storage, contracts, and keys.

```cadence
fun Account(payer: auth(BorrowValue | Storage) &Account):
	auth(Storage, Contracts, Keys, Inbox, Capabilities) &Account
```

For example, the following transaction creates a new account
and has the signer of the transaction pay for it:

```cadence
transaction {
    prepare(signer: auth(BorrowValue) &Account) {
        let account = Account(payer: signer)
    }
}
```

## Account keys

An account has keys associated with it.
An account key has the following structure.

```cadence
struct AccountKey {
    let keyIndex: Int
    let publicKey: PublicKey
    let hashAlgorithm: HashAlgorithm
    let weight: UFix64
    let isRevoked: Bool
}
```

Refer to the [`PublicKey` section](./crypto.mdx#publickey) for more details on the creation and validity of public keys.

An account exposes its keys through the `keys` field,
which has the type `Account.Keys`.

### Adding an account key

The function `keys.add` allows a key to access an account.

```cadence
access(Keys | AddKey)
fun add(
    publicKey: PublicKey,
    hashAlgorithm: HashAlgorithm,
    weight: UFix64
): AccountKey
```

Calling the `add` function requires access to an account via a reference which is authorized
with the coarse-grained `Keys` entitlement (`auth(Keys) &Account`),
or the fine-grained `AddKey` entitlement (`auth(AddKey) &Account`).

For example, to add a public key to an existing account,
which signed the transaction:

```cadence
transaction(publicKey: [UInt8]) {
    prepare(signer: auth(AddKey) &Account) {
        let key = PublicKey(
            publicKey: publicKey,
            signatureAlgorithm: SignatureAlgorithm.ECDSA_P256
        )

        signer.keys.add(
            publicKey: key,
            hashAlgorithm: HashAlgorithm.SHA3_256,
            weight: 10.0
        )
    }
}
```

A more complex transaction, which creates an account,
has the signer of the transaction pay for the account creation,
and authorizes one key to access the account,
could look like:

```cadence
transaction(publicKey: [UInt8]) {
    prepare(signer: auth(BorrowValue) &Account) {
        let key = PublicKey(
            publicKey: publicKey,
            signatureAlgorithm: SignatureAlgorithm.ECDSA_P256
        )

        let account = Account(payer: signer)

        account.keys.add(
            publicKey: key,
            hashAlgorithm: HashAlgorithm.SHA3_256,
            weight: 10.0
        )
    }
}
```

### Getting an account key

The functions `keys.get` and `keys.forEach` allow retrieving the keys of an account.

The `get` function allows retrieving a key with a specific index.
The function returns the key if it exists, and `nil` otherwise.

```cadence
access(all)
view fun get(keyIndex: Int): AccountKey?
```

The `forEach` function allows iterating over all keys of an account.

```cadence
access(all)
fun forEach(_ function: fun(AccountKey): Bool)
```

For each key of the account, the `forEach` function calls the given callback, passing the key to it.
When the callback function returns `true` the iteration continues,
and when it returns `false`, iteration stops.

<Callout type="warning">
    The `keys.get` and `keys.forEach` functions include revoked keys,
    which have the `isRevoked` field set to `true`.
</Callout>

```cadence
access(all)
fun main() {
    let account = getAccount(0x42)

    // Get the third key from the account.
    let thirdKey = account.keys.get(keyIndex: 2)
    // ...

    // Iterate over all keys of the account.
    account.keys.forEach(fun (key: AccountKey): Bool {
        // ...
        return true
    })
}
```

### Revoking an account key

The `revoke` function revokes a key from accessing an account.
The function only marks the key at the given index as revoked, but never deletes it.

```cadence
access(Keys | RevokeKey)
fun revoke(keyIndex: Int): AccountKey?
```

Calling the `revoke` function requires access to an account via a reference which is authorized
with the coarse-grained `Keys` entitlement (`auth(Keys) &Account`),
or the fine-grained `RevokeKey` entitlement (`auth(RevokeKey) &Account`).

For example, to revoke the third key of the account which signed the transaction:

```cadence
transaction {
    prepare(signer: auth(RevokeKey) &Account) {
        let revokedKey = signer.keys.revoke(keyIndex: 2)
        // ...
    }
}
```

## Account inbox

Accounts have an inbox,
which allows making [capabilities](./capability-based-access-control.md) available to specific accounts.
The inbox provides a convenient way to "bootstrap" capabilities:
setting up an initial connection between two accounts,
that the accounts can use to transfer data or perform actions.

An account exposes its inbox through the `inbox` field,
which has the type `Account.Inbox`.

### Publishing a capability to the account inbox

An account (the provider) that would like to provide a capability to another account (the recipient) can do so using the `publish` function:

```cadence
access(Inbox | PublishInboxCapability)
fun publish(_ value: Capability, name: String, recipient: Address)
```

Calling the `publish` function requires access to an account via a reference which is authorized
with the coarse-grained `Inbox` entitlement (`auth(Inbox) &Account`),
or the fine-grained `PublishInboxCapability` entitlement (`auth(PublishInboxCapability) &Account`).

The function publishes the specified capability using the provided string as an identifier, to be later claimed by the recipient.
Note, however, that until the recipient claims the capability, the provider's account stores it,
and the capability contributes towards the provider's account storage usage.

Calling this function emits an event, `InboxValuePublished`,
that includes the address of both the provider and the recipient, as well as the name and the type of the published capability.
Refer to the [Core Events page](./core-events.md#inbox-value-published) for more details on this event.

### Claiming a capability from the account inbox

The intended recipient of a capability can claim a capability from the provider using the `claim` function:

```cadence
access(Inbox | ClaimInboxCapability)
fun claim<T: &Any>(_ name: String, provider: Address): Capability<T>?
```

Calling the `claim` function requires access to an account via a reference which is authorized
with the coarse-grained `Inbox` entitlement (`auth(Inbox) &Account`),
or the fine-grained `ClaimInboxCapability` entitlement (`auth(ClaimInboxCapability) &Account`).

If the provider's inbox has a capability stored under the provided name,
the calling recipient is the intended recipient,
and it conforms to the provided type argument,
then the function removes the capability from the provider's inbox and returns it.

If the provider's inbox has no capability stored under the provided name,
or if the calling recipient is not the intended recipient,
the function returns `nil`.
If the borrow type of the capability is not a subtype of the provided type argument,
the program aborts.

<Callout type="info">
    It is only possible to claim a capability once.
</Callout>

Calling function `claim` function emits an event, `InboxValueClaimed`,
that includes the address of both the provider and the recipient,
as well as the name of the claimed capability.
Refer to the [Core Events page](./core-events.md#inbox-value-claimed) for more details on this event.

### Unpublishing a capability from the account inbox

If the provider no longer wishes to publish a capability for some reason,
they can unpublish the capability using the `unpublish` function:

```cadence
access(Inbox | UnpublishInboxCapability)
fun unpublish<T: &Any>(_ name: String): Capability<T>?
```

Calling the `unpublish` function requires access to an account via a reference which is authorized
with the coarse-grained `Inbox` entitlement (`auth(Inbox) &Account`),
or the fine-grained `UnpublishInboxCapability` entitlement (`auth(UnpublishInboxCapability) &Account`).

If the provider's inbox has a capability stored under the provided name,
and it conforms to the provided type argument,
then the function removes the capability from the inbox and returns it.

If the provider's inbox has no capability stored under the provided name,
the function returns `nil`.
If the borrow type of the capability is not a subtype of the provided type argument,
the program aborts.

Calling the `unpublish` function emits an event, `InboxValueUnpublished`,
that includes the address of the provider, and the name of the unpublished capability.
Refer to the [Core Events page](./core-events.md#inbox-value-unpublished) for more details on this event.

## Account storage

Accounts allow storing storable objects, such as resources and structures.

### Paths

Account storage stores objects under paths.
Paths consist of a domain and an identifier.

Paths start with the character `/`, followed by the domain, the path separator `/`,
and finally the identifier.
For example, the path `/storage/test` has the domain `storage` and the identifier `test`.

There are two valid domains: `storage` and `public`.

Paths in the storage domain have type `StoragePath`,
and paths in the public domain have the type `PublicPath`.
Both `StoragePath` and `PublicPath` are subtypes of `Path`.

The `storage` domain stores storable objects, such as resources and structs.
Objects stored under the `storage` domain are only accessible through account references
which are authorized with a storage entitlement.

The `public` domain stores capabilities,
which are accessible by anyone.

#### Path functions

```cadence
fun toString(): String
```

Returns the string representation of the path.

```cadence
let storagePath = /storage/path

storagePath.toString()  // is "/storage/path"
```

There are also utilities to produce paths from strings:

```cadence
fun PublicPath(identifier: string): PublicPath?
fun StoragePath(identifier: string): StoragePath?
```

Each of these functions take an identifier and produce a path of the appropriate domain:

```cadence
let pathID = "foo"
let path = PublicPath(identifier: pathID) // is /public/foo
```

### Account storage API

An account exposes its storage through the `storage` field,
which has the type `Account.Storage`.

#### Saving objects

```cadence
access(Storage | SaveValue)
fun save<T: Storable>(_ value: T, to: StoragePath)
```

The `save` function saves an object to account storage.
The function moves resources, and copies structures.
If there is already an object stored under the given path, the program aborts.
The path must be a storage path, it must have the domain `storage`.

`T` is the type parameter for the object type.
Cadence can infer this type parameter from the argument's type.

#### Getting object type information

```cadence
access(all)
view fun type(at path: StoragePath): Type?
```

The `type` function returns the type of the object stored under the given path,
or `nil` if the account does not store an object under the given path.

The function does not change the stored object.

The path must be a storage path, it must have the domain `storage`.

#### Removing objects

```cadence
access(Storage | LoadValue)
fun load<T: Storable>(from: StoragePath): T?
```

The `load` function loads an object from account storage.
If there is an object stored under the given path,
the function moves the stored resource or structure out of storage
and returns it as an optional.
If there is no object stored under the given path,
the function returns `nil`.
When the function returns with an object,
the storage no longer stores an object under the given path.

`T` is the type parameter for the object type.
Programs must explicitly provide a type argument for the parameter.

The type `T` must be a supertype of the type of the loaded object.
If it is not, the program aborts.
The given type does not necessarily need to be exactly the same as the type of the loaded object.

The path must be a storage path, it must have the domain `storage`.

#### Copying objects

```cadence
access(Storage | CopyValue)
view fun copy<T: AnyStruct>(from: StoragePath): T?
```

The `copy` function returns a copy of a structure stored in account storage,
without removing it from storage.
If there is a structure stored under the given path,
the function copies the stored structure and returns it as an optional.
If there is no structure stored under the given path,
the function returns `nil`.
When the function returns with an object,
the structure stays stored in storage after the function returns.

`T` is the type parameter for the structure type.
Programs must explicitly provide a type argument for the parameter.

The type `T` must be a supertype of the type of the copied structure.
If it is not, the program aborts.
The given type does not necessarily have to be exactly the same as the type of the copied structure.

The path must be a storage path, it must have the domain `storage`.

#### Accessing objects

```cadence
access(Storage | BorrowValue)
view fun borrow<T: &Any>(from: StoragePath): T?
```

The `borrow` function returns a reference to an objects stored in storage,
without removing the object from storage.
The function makes it convenient to work with objects in storage
without having to move them out of storage.

If there is a structure stored under the given path,
the function creates a reference to the object and returns the reference as an optional.
If there is no structure stored under the given path,
the function returns `nil`.

`T` is the type parameter for the object type.
Programs must explicitly provide a type argument for the parameter.

The type argument must be a reference to any type, `&Any` (`Any` is the supertype of all types).
The type `T` must be a supertype of the type of the borrowed object.
If it is not, the program aborts.
The given type does not necessarily have to be exactly the same as the type of the borrowed object.

The path must be a storage path, it must have the domain `storage`.

#### Example

```cadence
// Declare a resource interface named `HasCount`, that has a field `count`
//
resource interface HasCount {
    count: Int
}

// Declare a resource named `Counter` that conforms to `HasCount`
//
resource Counter: HasCount {
    access(all)
    var count: Int

    access(all)
    init(count: Int) {
        self.count = count
    }
}

// In this example, an authorized reference to an account
// is available through the constant `account`.

// Create a new instance of the resource type `Counter`
// and save it in the storage of the account.
//
// The path `/storage/counter` is used to refer to the stored value.
// Its identifier `counter` was chosen freely and could be something else.
//
account.storage.save(
    <-create Counter(count: 42),
    to: /storage/counter
)

// Run-time error: Storage already contains an object under path `/storage/counter`
//
account.storage.save(
    <-create Counter(count: 123),
    to: /storage/counter
)

// Load the `Counter` resource from storage path `/storage/counter`.
//
// The new constant `counter` has the type `Counter?`, i.e., it is an optional,
// and its value is the counter resource, that was saved at the beginning
// of the example.
//
let counter <- account.storage.load<@Counter>(from: /storage/counter)

// The storage is now empty, there is no longer an object stored
// under the path `/storage/counter`.

// Load the `Counter` resource again from storage path `/storage/counter`.
//
// The new constant `counter2` has the type `Counter?` and is `nil`,
// as nothing is stored under the path `/storage/counter` anymore,
// because the previous load moved the counter out of storage.
//
let counter2 <- account.storage.load<@Counter>(from: /storage/counter)

// Create another new instance of the resource type `Counter`
// and save it in the storage of the account.
//
// The path `/storage/otherCounter` is used to refer to the stored value.
//
account.storage.save(
    <-create Counter(count: 123),
    to: /storage/otherCounter
)

// Load the `Vault` resource from storage path `/storage/otherCounter`.
//
// The new constant `vault` has the type `Vault?` and its value is `nil`,
// as there is a resource with type `Counter` stored under the path,
// which is not a subtype of the requested type `Vault`.
//
let vault <- account.storage.load<@Vault>(from: /storage/otherCounter)

// The storage still stores a `Counter` resource under the path `/storage/otherCounter`.

// Save the string "Hello, World" in storage
// under the path `/storage/helloWorldMessage`.

account.storage.save(
    "Hello, world!",
    to: /storage/helloWorldMessage
)

// Copy the stored message from storage.
//
// After the copy, the storage still stores the string under the path.
// Unlike `load`, `copy` does not remove the object from storage.
//
let message = account.storage.copy<String>(from: /storage/helloWorldMessage)

// Create a new instance of the resource type `Vault`
// and save it in the storage of the account.
//
account.storage.save(
    <-createEmptyVault(),
    to: /storage/vault
)

// Invalid: Cannot copy a resource, as this would allow arbitrary duplication.
//
let vault <- account.storage.copy<@Vault>(from: /storage/vault)

// Create a reference to the object stored under path `/storage/counter`,
// typed as `&Counter`.
//
// `counterRef` has type `&Counter?` and is a valid reference, i.e. non-`nil`,
// because the borrow succeeded:
//
// There is an object stored under path `/storage/otherCounter`
// and it has type `Counter`, so it can be borrowed as `&Counter`
//
let counterRef = account.storage.borrow<&Counter>(from: /storage/otherCounter)

counterRef?.count // is `42`

// Create a reference to the object stored under path `/storage/otherCounter`,
// typed as `&{HasCount}`.
//
// `hasCountRef` is non-`nil`, as there is an object stored under path `/storage/otherCounter`,
// and the stored value of type `Counter` conforms to the requested type `{HasCount}`:
// the type `Counter` implements the intersection type's interface `HasCount`

let hasCountRef = account.storage.borrow<&{HasCount}>(from: /storage/otherCounter)

// Create a reference to the object stored under path `/storage/otherCounter`,
// typed as `&{SomethingElse}`.
//
// `otherRef` is `nil`, as there is an object stored under path `/storage/otherCounter`,
// but the stored value of type `Counter` does not conform to the requested type `{SomethingElse}`:
// the type `Counter` does not implement the intersection type's interface `SomethingElse`

let otherRef = account.storage.borrow<&{SomethingElse}>(from: /storage/otherCounter)

// Create a reference to the object stored under path `/storage/nonExistent`,
// typed as `&{HasCount}`.
//
// `nonExistentRef` is `nil`, as there is nothing stored under path `/storage/nonExistent`
//
let nonExistentRef = account.storage.borrow<&{HasCount}>(from: /storage/nonExistent)
```

### Iterating over stored objects

The following functions allow iterating over an account's storage:

```cadence
fun forEachPublic(_ function: fun(PublicPath, Type): Bool)
fun forEachStored(_ function: fun(StoragePath, Type): Bool)
```

The functions iterate over all stored objects in the particular domain,
calling the callback function for each stored object,
passing the path and the run-time type of the stored object.

The `Bool` value returned from the callback function determines whether iteration continues.
If the callback function returns `true`, iteration proceeds to the next stored object.
If the callback function returns `false`, the iteration function stops.
The specific order in which the objects are iterated over is undefined,
as is the behavior when a path is added or removed from storage.

<Callout type="warning">
The order of iteration is undefined. Do not rely on any particular behavior.

Saving an object to a path or loading an object from storage during iteration
can cause the order in which values are stored to change arbitrarily.

When a program continues to iterate after such an operation, the program aborts.

To avoid such errors, do not save objects to storage or load objects from storage during iteration.
If you do perform such an operation,
return `false` from the iteration callback to cause iteration to end after the mutation like so:

```cadence
account.storage.save(1, to: /storage/foo1)
account.storage.save(2, to: /storage/foo2)
account.storage.save(3, to: /storage/foo3)
account.storage.save("qux", to: /storage/foo4)

account.storage.forEachStored(fun (path: StoragePath, type: Type): Bool {
    if type == Type<String>() {
        // Save a value to storage while iterating
        account.storage.save("bar", to: /storage/foo5)

        // Returning false here ends iteration after storage is modified,
        // preventing the program from aborting
        return false
    }

    return true
})
```

</Callout>

<Callout type="info">
    The iteration functions skip broken objects.

    An object could be broken due to invalid types associated with the stored value.
    For example, the contract for the stored object might have syntactic or semantic errors.
</Callout>

### Storage limit

An account's storage is limited by its storage capacity.

An account's storage used is the sum of the size of all the data that the account stores, in MB.
An account's storage capacity is a value that is calculated from the amount of FLOW
that is stored in the account's main FLOW token vault.

At the end of every transaction, the storage used is compared to the storage capacity.
For all accounts involved in the transaction,
if the account's storage used is greater than its storage capacity, the transaction fails.

An account exposes its storage used through the `storage.used` field,
and its storage capacity through the `storageCapacity` field.

The fields represent current values:

```cadence
// Query the storage used before saving an object
let storageUsedBefore = account.storage.used

// Save a resource into storage
account.storage.save(
    <-create Counter(count: 123),
    to: /storage/counter
)

// Query the storage used again after saving
let storageUsedAfter = account.storage.used

let storageUsedChanged = storageUsedAfter > storageUsedBefore  // is true
```
