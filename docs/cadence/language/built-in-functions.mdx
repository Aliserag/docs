---
title: Built-in Functions
sidebar_position: 28
---

## panic
#

```cadence
fun panic(_ message: String): Never
```

  Terminates the program unconditionally
  and reports a message which explains why the unrecoverable error occurred.

  ```cadence
  let optionalAccount: AuthAccount? = // ...
  let account = optionalAccount ?? panic("missing account")
  ```

## assert

```cadence
fun assert(_ condition: Bool, message: String)
```

  Terminates the program if the given condition is false,
  and reports a message which explains how the condition is false.
  Use this function for internal sanity checks.

  The message argument is optional.

```markdown
## secureRandom

```cadence
fun secureRandom(): UInt64
```

  Returns a pseudo-random number. The sequence of generated randoms is of high statistical quality and cryptographically secure.
  We highlight that the random number generation process is unpredictable (for miners unpredictable at block construction time
  and for cadence logic unpredictable at time of call), verifiable, uniform, as well as unbiasable by miners and previously-running
  Cadence code. For more details, please see <Link to Flow Randomness blog post — still pending publication>

  Nevertheless, developers need to be mindful to use `secureRandom()` correctly to not undermine unbiasability and unpredictability.
  **A transaction can atomically revert all its action at any time. Therefore, it is possible for a transaction calling into your
  smart contract to post-select favourable results and revert the transaction for unfavourable results**
  ([Ethereum example](https://consensys.github.io/smart-contract-best-practices/development-recommendations/general/public-data/)).
  This limitation is inherent to any smart contract platform that allows transactions to roll back atomically and cannot be
  solved through secure randomness alone. 

  ### Guidelines for safe usage: 
  
  The central aspect that you as a developer have to think about is the following scenario:

  - Imagine an adversarial user that is sending a transaction that calls your smart contract.
  - The transaction includes code that runs *after* your smart contract returns and inspects the outcome.
    If the outcome is unfavorable (based on some criteria codified in the transaction), the transaction aborts itself.

  While `secureRandom()` prevents *pre*-selection attacks (i.e. biasing by minders or transaction logic before getting the
  random number), the scenario we just described is essentially a *post*-selection attack. The ability to post-select outputs
  can only be mitigated by restricting the client to revert computation.

  You as a developer need to decide whether your use-case is sensitive to transactions aborting. 

  1. For some use cases it might be irrelevant or event disadvantageous for transactions to abort. If the transactions that are
    authorized to trigger the random number generation are coming from an honest source (such as the smart contract developer),
    transaction aborting themselves might not be a challenge.
    
    In this case, you can simply use `secureRandom()` without security concerns.
    
  2. However, if an adversarial client has an incentive to post-select depending on the values of the generated random(s),
    you need to need to implement a commit-reveal-recover scheme. An intuitive example could be a rock-paper-scissors game.
    We generally don’t want that clients can inspect the result of a game and abort if they lost only to repeat the game
    later again until they eventually win. 
    
    We recommend the following as a best-practise example for implementing a commit-reveal-recover scheme in cadence.
    Conceptually, our example implements the same approach as this
    [Ethereum example](https://consensys.github.io/smart-contract-best-practices/development-recommendations/general/public-data/). 
    
    While the commit-and-reveal scheme mitigates post-selection of results by adversarial clients,
    Flow’s secure randomness additionally mitigates any pre-selection vulnerabilities (like biasing attacks by byzantine miners).
```

## RLP

RLP (Recursive Length Prefix) serialization allows the encoding of arbitrarily nested arrays of binary data.

Cadence provides RLP decoding functions in the built-in `RLP` contract, which does not need to be imported.

-
    ```cadence
    fun decodeString(_ input: [UInt8]): [UInt8]
    ```

    Decodes an RLP-encoded byte array (called string in the context of RLP).
    The byte array should only contain of a single encoded value for a string; if the encoded value type does not match, or it has trailing unnecessary bytes, the program aborts.
    If any error is encountered while decoding, the program aborts.



    ```cadence
    fun decodeList(_ input: [UInt8]): [[UInt8]]`
    ```

    Decodes an RLP-encoded list into an array of RLP-encoded items.
    Note that this function does not recursively decode, so each element of the resulting array is RLP-encoded data.
    The byte array should only contain of a single encoded value for a list; if the encoded value type does not match, or it has trailing unnecessary bytes, the program aborts.
    If any error is encountered while decoding, the program aborts.
